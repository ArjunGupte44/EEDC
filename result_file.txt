{
    "0": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n\n\nconst size_t    LINE_SIZE = 64;\n\nclass Apr\n{\npublic:\n    Apr() \n    {\n        apr_initialize();\n    }\n\n    ~Apr() \n    {\n        apr_terminate();\n    }\n};\n\nstruct Node \n{\n    Node *l, *r;\n    \n    int check() const \n    {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nclass NodePool\n{\npublic:\n    NodePool() \n    {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() \n    {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc()\n    {\n        return (Node *)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear()\n    {\n        apr_pool_clear(pool);\n    }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode *make(int d, NodePool &store)\n{\n    Node* root = store.alloc();\n\n    if(d>0){\n        root->l=make(d-1, store);\n        root->r=make(d-1, store);\n    }else{\n        root->l=root->r=0;\n    }\n\n    return root;\n}\n\nint main(int argc, char *argv[]) \n{\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2,\n                             (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth+1;\n\n    // Alloc then dealloc stretchdepth tree\n    {\n        NodePool store;\n        Node *c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    // buffer to store output of each thread\n    char *outputstr = (char*)malloc(LINE_SIZE * (max_depth +1) * sizeof(char));\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        // Create a memory pool for this thread to use.\n        NodePool store;\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            Node *a = make(d, store);\n            c += a->check();\n            store.clear();\n        }\n\n        // each thread write to separate location\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    // print all results\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + (d * LINE_SIZE) );\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << (long_lived_tree->check()) << \"\\n\";\n\n    return 0;\n}",
        52.301,
        547.065
    ],
    "1": [
        "#include <iostream>\n#include <cstdlib>\n#include <apr_pools.h>\n#include <omp.h>\n#include <cstddef>  // Added for size_t\n#include <vector>\n#include <string>\n\nconst size_t LINE_SIZE = 128;\n\nclass Apr\n{\npublic:\n    Apr() \n    {\n        apr_initialize();\n    }\n\n    ~Apr() \n    {\n        apr_terminate();\n    }\n};\n\nstruct Node \n{\n    Node *l, *r;\n    \n    int check() const \n    {\n        // Iterative approach here if needed\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nclass NodePool\n{\npublic:\n    NodePool() \n    {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() \n    {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc()\n    {\n        return (Node *)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear()\n    {\n        apr_pool_clear(pool);\n    }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode* iterativeMake(int depth, NodePool &store) {\n    std::vector<Node*> nodes;\n    nodes.reserve((1 << (depth + 1)) - 1); // Reserve memory based on the full binary tree formula\n\n    Node* root = store.alloc();\n    nodes.push_back(root);\n\n    for (int i = 0; i < (1 << depth) - 1; ++i) {\n        Node* node = nodes[i];\n        if (i * 2 + 1 < nodes.capacity()) { // left child index\n            node->l = store.alloc();\n            nodes.push_back(node->l);\n        } else {\n            node->l = nullptr;\n        }\n\n        if (i * 2 + 2 < nodes.capacity()) { // right child index\n            node->r = store.alloc();\n            nodes.push_back(node->r);\n        } else {\n            node->r = nullptr;\n        }\n    }\n\n    return root;\n}\n\nint main(int argc, char *argv[]) \n{\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2,(argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth+1;\n\n    // Alloc and dealloc stretchdepth tree\n    {\n        NodePool store;\n        Node *c = iterativeMake(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node *long_lived_tree = iterativeMake(max_depth, long_lived_store);\n\n    // Use a dynamically allocated buffer with better bounds management\n    std::vector<std::string> outputs(max_depth/2 + 1);\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        // Create a memory pool for this thread to use.\n        NodePool store;\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            Node *a = iterativeMake(d, store);\n            c += a->check();\n            store.clear();\n        }\n\n        // Store output safely\n        #pragma omp critical\n        {\n            outputs[(d - min_depth)/2] = std::to_string(iterations) + \"\\t trees of depth \" + std::to_string(d) + \"\\t check: \" + std::to_string(c) + \"\\n\";\n        }\n    }\n\n    // Print all results\n    for (const auto& output : outputs) \n        std::cout << output;\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \" \n              << \"check: \" << (long_lived_tree->check()) << std::endl;\n\n    return 0;\n}",
        55.228,
        542.56
    ],
    "2": [
        "#include <iostream>\n#include <vector>\n#include <string>\n#include <omp.h>\n#include <sstream>\n#include <deque>\n\nclass Node {\npublic:\n    Node *l, *r;\n\n    Node() : l(nullptr), r(nullptr) {}\n\n    // Iterative check function to avoid recursion\n    int check() const {\n        int count = 0;\n        std::deque<const Node*> stack;\n        stack.push_back(this);\n        while (!stack.empty()) {\n            const Node* current = stack.back();\n            stack.pop_back();\n            ++count;\n            if (current->l) stack.push_back(current->l);\n            if (current->r) stack.push_back(current->r);\n        }\n        return count;\n    }\n};\n\nclass NodePool {\npublic:\n    std::deque<Node> pool;\n    size_t index;\n\n    NodePool(size_t capacity) : pool(capacity), index(0) {}\n\n    Node* alloc() {\n        if (index < pool.size()) {\n            return &pool[index++];\n        }\n        return nullptr;\n    }\n\n    void clear() {\n        index = 0;\n    }\n};\n\nNode* make(int depth, NodePool& store) {\n    if (depth <= 0) return nullptr;\n    Node* root = store.alloc();\n    if (!root) return nullptr;\n\n    std::deque<std::pair<Node*, int>> stack;\n    stack.emplace_back(root, depth);\n\n    while (!stack.empty()) {\n        auto [node, d] = stack.back();\n        stack.pop_back();\n\n        if (d > 0) {\n            node->l = store.alloc();\n            node->r = store.alloc();\n\n            if (node->r) stack.emplace_back(node->r, d - 1);\n            if (node->l) stack.emplace_back(node->l, d - 1);\n        }\n    }\n    return root;\n}\n\nint main(int argc, char* argv[]) \n{\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? std::atoi(argv[1]) : 10));\n\n    // Calculate and print the stretch tree\n    {\n        NodePool stretch_pool(1 << (max_depth + 2));\n        Node* stretch_tree = make(max_depth + 1, stretch_pool);\n        std::cout << \"stretch tree of depth \" << (max_depth + 1) << \"\\t check: \" \n                  << (stretch_tree ? stretch_tree->check() : 0) << std::endl;\n    }\n\n    std::vector<std::string> outputs((max_depth / 2) + 1);\n    NodePool long_lived_store(1 << (max_depth + 1));\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int total_check = 0;\n\n        #pragma omp parallel reduction(+:total_check)\n        {\n            NodePool store(1 << (d + 1));\n            #pragma omp for schedule(static)\n            for (int i = 0; i < iterations; ++i) {\n                Node *a = make(d, store);\n                if (a) total_check += a->check();\n                store.clear();\n            }\n        }\n\n        std::ostringstream oss;\n        oss << iterations << \"\\t trees of depth \" << d << \"\\t check: \" << total_check << '\\n';\n        outputs[(d - min_depth) / 2] = oss.str();\n    }\n\n    for (const auto& output : outputs)\n        std::cout << output;\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \" \n              << \"check: \" << (long_lived_tree ? long_lived_tree->check() : 0) << std::endl;\n\n    return 0;\n}",
        156.378,
        1921.642
    ],
    "3": [
        "#include <iostream>\n#include <vector>\n#include <string>\n#include <omp.h>\n#include <sstream>\n\nclass Node {\npublic:\n    Node *l, *r;\n\n    Node() : l(nullptr), r(nullptr) {}\n\n    int check() const {\n        int count = 0;\n        std::vector<const Node*> stack;\n        stack.push_back(this);\n        while (!stack.empty()) {\n            const Node* current = stack.back();\n            stack.pop_back();\n            ++count;\n            if (current->l) stack.push_back(current->l);\n            if (current->r) stack.push_back(current->r);\n        }\n        return count;\n    }\n};\n\nclass NodePool {\npublic:\n    std::vector<Node> pool;\n    size_t index;\n\n    NodePool(size_t capacity) : pool(capacity), index(0) {}\n\n    Node* alloc() {\n        if (index < pool.size()) {\n            return &pool[index++];\n        }\n        return nullptr;\n    }\n\n    void clear() {\n        index = 0;\n    }\n};\n\nNode* make(int depth, NodePool& store) {\n    if (depth <= 0) return nullptr;\n    Node* root = store.alloc();\n    if (!root) return nullptr;\n    \n    std::vector<std::pair<Node*, int>> stack;\n    stack.emplace_back(root, depth);\n\n    while (!stack.empty()) {\n        auto [node, d] = stack.back();\n        stack.pop_back();\n\n        if (d > 0) {\n            node->l = store.alloc();\n            node->r = store.alloc();\n\n            if (node->r) stack.emplace_back(node->r, d - 1);\n            if (node->l) stack.emplace_back(node->l, d - 1);\n        }\n    }\n    return root;\n}\n\nint main(int argc, char* argv[]) \n{\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? std::atoi(argv[1]) : 10));\n\n    {\n        NodePool stretch_pool(1 << (max_depth + 2));\n        Node* stretch_tree = make(max_depth + 1, stretch_pool);\n        std::cout << \"stretch tree of depth \" << (max_depth + 1) << \"\\t check: \" \n                  << (stretch_tree ? stretch_tree->check() : 0) << std::endl;\n    }\n\n    std::vector<std::string> outputs((max_depth / 2) + 1);\n    NodePool long_lived_store(1 << (max_depth + 1));\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int total_check = 0;\n\n        #pragma omp parallel reduction(+:total_check)\n        {\n            NodePool store(1 << (d + 1));\n            #pragma omp for schedule(static)\n            for (int i = 0; i < iterations; ++i) {\n                Node *a = make(d, store);\n                if (a) total_check += a->check();\n                store.clear();\n            }\n        }\n\n        std::ostringstream oss;\n        oss << iterations << \"\\t trees of depth \" << d << \"\\t check: \" << total_check << '\\n';\n        outputs[(d - min_depth) / 2] = oss.str();\n    }\n\n    for (const auto& output : outputs)\n        std::cout << output;\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \" \n              << \"check: \" << (long_lived_tree ? long_lived_tree->check() : 0) << std::endl;\n\n    return 0;\n}",
        85.195,
        785.444
    ],
    "4": [
        "#include <iostream>\n#include <vector>\n#include <string>\n#include <omp.h>\n#include <sstream>\n#include <queue>\n\nclass Node {\npublic:\n    Node *l, *r;\n\n    Node() : l(nullptr), r(nullptr) {}\n\n    int check() const {\n        int count = 0;\n        std::vector<const Node*> stack;\n        stack.push_back(this);\n        while (!stack.empty()) {\n            const Node* current = stack.back();\n            stack.pop_back();\n            ++count;\n            if (current->l) stack.push_back(current->l);\n            if (current->r) stack.push_back(current->r);\n        }\n        return count;\n    }\n};\n\nclass NodePool {\npublic:\n    std::vector<Node> pool;\n    size_t index;\n\n    NodePool(size_t capacity) : pool(capacity), index(0) {}\n\n    Node* alloc() {\n        if (index < pool.size()) {\n            return &pool[index++];\n        }\n        return nullptr;\n    }\n\n    void clear() {\n        index = 0;\n    }\n};\n\nNode* make(int depth, NodePool& store) {\n    if (depth <= 0) return nullptr;\n    std::queue<std::pair<Node*, int>> queue;\n    Node* root = store.alloc();\n    if (!root) return nullptr;\n    queue.push({root, depth});\n\n    while (!queue.empty()) {\n        auto [node, d] = queue.front();\n        queue.pop();\n        if (d > 0) {\n            node->l = store.alloc();\n            node->r = store.alloc();\n            if (node->l) queue.push({node->l, d - 1});\n            if (node->r) queue.push({node->r, d - 1});\n        }\n    }\n    return root;\n}\n\nint main(int argc, char* argv[]) \n{\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? std::atoi(argv[1]) : 10));\n\n    {\n        NodePool stretch_pool(1 << (max_depth + 2));\n        Node* stretch_tree = make(max_depth + 1, stretch_pool);\n        std::cout << \"stretch tree of depth \" << (max_depth + 1) << \"\\t check: \" \n                  << (stretch_tree ? stretch_tree->check() : 0) << std::endl;\n    }\n\n    std::vector<std::string> outputs((max_depth / 2) + 1);\n    NodePool long_lived_store(1 << (max_depth + 1));\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int total_check = 0;\n\n        #pragma omp parallel reduction(+:total_check)\n        {\n            NodePool store(1 << (d + 1));\n            #pragma omp for schedule(static)\n            for (int i = 0; i < iterations; ++i) {\n                Node *a = make(d, store);\n                if (a) total_check += a->check();\n                store.clear();\n            }\n        }\n\n        std::ostringstream oss;\n        oss << iterations << \"\\t trees of depth \" << d << \"\\t check: \" << total_check << '\\n';\n        outputs[(d - min_depth) / 2] = oss.str();\n    }\n\n    for (const auto& output : outputs)\n        std::cout << output;\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \" \n              << \"check: \" << (long_lived_tree ? long_lived_tree->check() : 0) << std::endl;\n\n    return 0;\n}",
        116.631,
        1205.184
    ]
}