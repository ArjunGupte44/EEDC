{
    "0": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n\n\nconst size_t    LINE_SIZE = 64;\n\nclass Apr\n{\npublic:\n    Apr() \n    {\n        apr_initialize();\n    }\n\n    ~Apr() \n    {\n        apr_terminate();\n    }\n};\n\nstruct Node \n{\n    Node *l, *r;\n    \n    int check() const \n    {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nclass NodePool\n{\npublic:\n    NodePool() \n    {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() \n    {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc()\n    {\n        return (Node *)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear()\n    {\n        apr_pool_clear(pool);\n    }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode *make(int d, NodePool &store)\n{\n    Node* root = store.alloc();\n\n    if(d>0){\n        root->l=make(d-1, store);\n        root->r=make(d-1, store);\n    }else{\n        root->l=root->r=0;\n    }\n\n    return root;\n}\n\nint main(int argc, char *argv[]) \n{\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2,\n                             (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth+1;\n\n    // Alloc then dealloc stretchdepth tree\n    {\n        NodePool store;\n        Node *c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    // buffer to store output of each thread\n    char *outputstr = (char*)malloc(LINE_SIZE * (max_depth +1) * sizeof(char));\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        // Create a memory pool for this thread to use.\n        NodePool store;\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            Node *a = make(d, store);\n            c += a->check();\n            store.clear();\n        }\n\n        // each thread write to separate location\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    // print all results\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + (d * LINE_SIZE) );\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << (long_lived_tree->check()) << \"\\n\";\n\n    return 0;\n}",
        366.691,
        3251.624
    ],
    "1": [
        "#include <iostream>\n#include <vector>\n#include <stack>\n#include <sstream>\n#include <omp.h>\n\nstruct Node {\n    Node* l = nullptr;\n    Node* r = nullptr;\n    int check() const {\n        int check_value = 0;\n        std::stack<const Node*> stack;\n        stack.push(this);\n        while (!stack.empty()) {\n            const Node* node = stack.top();\n            stack.pop();\n            check_value++;\n            if (node->l) stack.push(node->l);\n            if (node->r) stack.push(node->r);\n        }\n        return check_value;\n    }\n};\n\nclass NodePool {\npublic:\n    std::vector<Node*> pool;\n\n    Node* alloc() {\n        if (!pool.empty()) {\n            Node* node = pool.back();\n            pool.pop_back();\n            return node;\n        }\n        return new Node();\n    }\n\n    void clear() {\n        for (auto* node : pool) {\n            delete node;\n        }\n        pool.clear();\n    }\n\n    void reclaim(Node* node) {\n        if (node != nullptr) {\n            node->l = nullptr;\n            node->r = nullptr;\n            pool.push_back(node);\n        }\n    }\n};\n\nNode* make_iterative(int depth, NodePool& store) {\n    if (depth == 0) return nullptr;\n\n    Node* root = store.alloc();\n    std::vector<Node*> nodes_at_current_depth;\n    nodes_at_current_depth.push_back(root);\n\n    for (int current_depth = 1; current_depth <= depth; ++current_depth) {\n        std::vector<Node*> next_level;\n        for (Node* node : nodes_at_current_depth) {\n            node->l = store.alloc();\n            node->r = store.alloc();\n            next_level.push_back(node->l);\n            next_level.push_back(node->r);\n        }\n        nodes_at_current_depth.swap(next_level);\n    }\n\n    return root;\n}\n\nvoid clear_tree(Node* root, NodePool& store) {\n    if (root) {\n        clear_tree(root->l, store);\n        clear_tree(root->r, store);\n        store.reclaim(root);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    // Stretch tree section.\n    {\n        NodePool store;\n        Node* c = make_iterative(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n        clear_tree(c, store);\n        store.clear();\n    }\n\n    NodePool long_lived_store;\n    Node* long_lived_tree = make_iterative(max_depth, long_lived_store);\n\n    std::vector<std::string> outputs(max_depth + 1);\n\n    #pragma omp parallel for\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n        NodePool store;\n        for (int i = 1; i <= iterations; ++i) {\n            Node* a = make_iterative(d, store);\n            c += a->check();\n            clear_tree(a, store);\n        }\n        std::ostringstream oss;\n        oss << iterations << \"\\t trees of depth \" << d << \"\\t check: \" << c << \"\\n\";\n\n        #pragma omp critical\n        outputs[d] = oss.str();\n    }\n\n    for (int d = min_depth; d <= max_depth; d += 2) \n        std::cout << outputs[d];\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << long_lived_tree->check() << \"\\n\";\n\n    clear_tree(long_lived_tree, long_lived_store);\n    long_lived_store.clear();\n\n    return 0;\n}\n",
        391.489,
        6856.442
    ],
    "2": [
        "#include <iostream>\n#include <vector>\n#include <stack>\n#include <sstream>\n#include <omp.h>\n\nstruct Node {\n    Node* l = nullptr;\n    Node* r = nullptr;\n    int check() const {\n        int check_value = 0;\n        std::stack<const Node*> stack;\n        stack.push(this);\n        while (!stack.empty()) {\n            const Node* node = stack.top();\n            stack.pop();\n            check_value++;\n            if (node->l) stack.push(node->l);\n            if (node->r) stack.push(node->r);\n        }\n        return check_value;\n    }\n};\n\nclass NodePool {\npublic:\n    std::vector<Node*> free_list;\n\n    Node* alloc() {\n        if (!free_list.empty()) {\n            Node* node = free_list.back();\n            free_list.pop_back();\n            return node;\n        }\n        return new Node();\n    }\n\n    void clear() {\n        for (auto* node : free_list) {\n            delete node;\n        }\n        free_list.clear();\n    }\n\n    void reclaim(Node* node) {\n        if (node != nullptr) {\n            node->l = nullptr;\n            node->r = nullptr;\n            free_list.push_back(node);\n        }\n    }\n};\n\nNode* make_iterative(int depth, NodePool& store) {\n    if (depth == 0) return nullptr;\n\n    Node* root = store.alloc();\n    std::vector<Node*> nodes_at_current_level = {root};\n\n    for (int current_depth = 1; current_depth <= depth; ++current_depth) {\n        std::vector<Node*> next_level;\n        for (Node* node : nodes_at_current_level) {\n            node->l = store.alloc();\n            node->r = store.alloc();\n            next_level.push_back(node->l);\n            next_level.push_back(node->r);\n        }\n        nodes_at_current_level.swap(next_level);\n    }\n\n    return root;\n}\n\nvoid clear_tree(Node* root, NodePool& store) {\n    if (root) {\n        clear_tree(root->l, store);\n        clear_tree(root->r, store);\n        store.reclaim(root);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    {\n        NodePool store;\n        Node* c = make_iterative(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n        clear_tree(c, store);\n        store.clear();\n    }\n\n    NodePool long_lived_store;\n    Node* long_lived_tree = make_iterative(max_depth, long_lived_store);\n\n    std::vector<std::string> outputs(max_depth + 1);\n\n    #pragma omp parallel for\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n        NodePool store;\n        std::ostringstream oss;\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node* a = make_iterative(d, store);\n            c += a->check();\n            clear_tree(a, store);\n        }\n\n        oss << iterations << \"\\t trees of depth \" << d << \"\\t check: \" << c << \"\\n\";\n        outputs[d] = oss.str();\n    }\n\n    for (const auto& output : outputs) {\n        if (!output.empty()) {\n            std::cout << output;\n        }\n    }\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n\n    clear_tree(long_lived_tree, long_lived_store);\n    long_lived_store.clear();\n\n    return 0;\n}",
        398.578,
        6849.664
    ],
    "3": [
        "#include <iostream>\n#include <vector>\n#include <stack>\n#include <cstdlib>\n#include <omp.h>\n\nstruct Node {\n    Node* l = nullptr;\n    Node* r = nullptr;\n    \n    // Method to perform iterative tree checking with stack\n    int check() const {\n        int check_value = 0;\n        std::stack<const Node*> stack;\n        stack.push(this);\n        while (!stack.empty()) {\n            const Node* node = stack.top();\n            stack.pop();\n            check_value++;\n            if (node->l) stack.push(node->l);\n            if (node->r) stack.push(node->r);\n        }\n        return check_value;\n    }\n};\n\nclass NodePool {\npublic:\n    std::vector<Node*> free_list;\n\n    // Efficient memory allocation using pooled nodes\n    Node* alloc() {\n        if (!free_list.empty()) {\n            Node* node = free_list.back();\n            free_list.pop_back();\n            return node;\n        }\n        return new Node();\n    }\n\n    // Clearing the pool by deallocating nodes\n    void clear() {\n        for (auto* node : free_list) {\n            delete node;\n        }\n        free_list.clear();\n    }\n\n    // Reclaim method to reset and recycle nodes\n    void reclaim(Node* node) {\n        if (node != nullptr) {\n            node->l = nullptr;\n            node->r = nullptr;\n            free_list.push_back(node);\n        }\n    }\n};\n\nNode* make_iterative(int depth, NodePool& store) {\n    if (depth == 0) return nullptr;\n\n    Node* root = store.alloc();\n    std::vector<Node*> nodes_at_current_level = {root};\n\n    for (int current_depth = 1; current_depth <= depth; ++current_depth) {\n        std::vector<Node*> next_level;\n        for (Node* node : nodes_at_current_level) {\n            node->l = store.alloc();\n            node->r = store.alloc();\n            next_level.push_back(node->l);\n            next_level.push_back(node->r);\n        }\n        nodes_at_current_level = std::move(next_level);\n    }\n\n    return root;\n}\n\nvoid clear_tree(Node* root, NodePool& store) {\n    if (root) {\n        clear_tree(root->l, store);\n        clear_tree(root->r, store);\n        store.reclaim(root);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? std::atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    {\n        NodePool store;\n        Node* c = make_iterative(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n        clear_tree(c, store);\n        store.clear();\n    }\n\n    NodePool long_lived_store;\n    Node* long_lived_tree = make_iterative(max_depth, long_lived_store);\n\n    std::vector<std::string> outputs(max_depth + 1);\n\n    #pragma omp parallel for\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n        NodePool store;\n        char buffer[256];\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node* a = make_iterative(d, store);\n            c += a->check();\n            clear_tree(a, store);\n        }\n\n        snprintf(buffer, sizeof(buffer), \"%d\\t trees of depth %d\\t check: %d\\n\", iterations, d, c);\n        #pragma omp critical\n        outputs[d] = buffer;\n    }\n\n    for (const auto& output : outputs) {\n        if (!output.empty()) {\n            std::cout << output;\n        }\n    }\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n\n    clear_tree(long_lived_tree, long_lived_store);\n    long_lived_store.clear();\n\n    return 0;\n}",
        403.561,
        6830.212
    ],
    "4": [
        "#include <iostream>\n#include <vector>\n#include <stack>\n#include <cstdlib>\n#include <omp.h>\n\nstruct Node {\n    Node* l = nullptr;\n    Node* r = nullptr;\n\n    // Method to perform iterative tree checking with stack\n    int check() const {\n        int check_value = 0;\n        std::stack<const Node*> stack;\n        stack.push(this);\n        while (!stack.empty()) {\n            const Node* node = stack.top();\n            stack.pop();\n            check_value++;\n            if (node->l) stack.push(node->l);\n            if (node->r) stack.push(node->r);\n        }\n        return check_value;\n    }\n};\n\nclass NodePool {\npublic:\n    std::vector<Node> nodes;\n    std::size_t next_free_index = 0;\n\n    NodePool(std::size_t preallocate_size) : nodes(preallocate_size) {}\n\n    // Efficient memory allocation using pooled nodes\n    Node* alloc() {\n        if (next_free_index < nodes.size()) {\n            Node* node = &nodes[next_free_index++];\n            node->l = nullptr;\n            node->r = nullptr;\n            return node;\n        }\n        // In case more nodes are needed, fallback to dynamic allocation\n        return new Node();\n    }\n\n    // Clear method adjusted to manage preallocated nodes\n    void clear() {\n        next_free_index = 0;\n    }\n\n    // Reclaim method streamlined for lightweight recycling\n    void reclaim(Node* node) {\n        // Manual reclamation not needed within prealloc range\n    }\n};\n\nNode* make_iterative(int depth, NodePool& store) {\n    if (depth == 0) return nullptr;\n\n    Node* root = store.alloc();\n    std::vector<Node*> nodes_at_current_level = {root};\n\n    for (int current_depth = 1; current_depth <= depth; ++current_depth) {\n        std::vector<Node*> next_level;\n        for (Node* node : nodes_at_current_level) {\n            node->l = store.alloc();\n            node->r = store.alloc();\n            next_level.push_back(node->l);\n            next_level.push_back(node->r);\n        }\n        nodes_at_current_level = std::move(next_level);\n    }\n\n    return root;\n}\n\nvoid clear_tree(Node* root, NodePool& store) {\n    if (root) {\n        clear_tree(root->l, store);\n        clear_tree(root->r, store);\n        store.reclaim(root);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? std::atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    std::size_t max_node_count = (1 << (max_depth + 1)) - 1;  // Max nodes at this depth\n    {\n        NodePool store(max_node_count);\n        Node* c = make_iterative(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n        clear_tree(c, store);\n        store.clear();\n    }\n\n    NodePool long_lived_store(max_node_count);\n    Node* long_lived_tree = make_iterative(max_depth, long_lived_store);\n\n    std::vector<std::string> outputs(max_depth + 1);\n\n    #pragma omp parallel for\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n        NodePool store(max_node_count);\n        char buffer[256];\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node* a = make_iterative(d, store);\n            c += a->check();\n            clear_tree(a, store);\n        }\n\n        snprintf(buffer, sizeof(buffer), \"%d\\t trees of depth %d\\t check: %d\\n\", iterations, d, c);\n        #pragma omp critical\n        outputs[d] = buffer;\n    }\n\n    for (const auto& output : outputs) {\n        if (!output.empty()) {\n            std::cout << output;\n        }\n    }\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n\n    clear_tree(long_lived_tree, long_lived_store);\n    long_lived_store.clear();\n\n    return 0;\n}",
        679.956,
        6110.978
    ]
}