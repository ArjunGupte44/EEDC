{
    "0": [
        "// g++ 4.8.x bug, compile with: -Wl,--no-as-needed option \n\n#include <iostream>\n#include <iomanip>\n#include <cstdint>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <future>\n#include <unistd.h>\n\nunsigned char tonum[256],tochar[4];\nstatic void init()\n{\n   tonum['A'] = 0;\n   tonum['C'] = 1;\n   tonum['T'] = 2;\n   tonum['G'] = 3;\n   tochar[0] = 'A';\n   tochar[1] = 'C';\n   tochar[2] = 'T';\n   tochar[3] = 'G';\n}\n\nstruct T{\n   T(const std::string& s = std::string())\n   :data(0),size(s.size())\n   {\n      reset(s,0,s.size());\n   }\n   void reset(const std::string& s,unsigned beg,unsigned end)\n   {\n      size = end-beg;\n      data = 0;\n      for(unsigned i = beg; i != end; ++i)\n      {\n         data <<= 2;\n         data |= tonum[unsigned(s[i])];\n      }\n   }\n   bool operator<(const T& in)const\n   {\n      return data < in.data;\n   }\n   bool operator==(const T& in)const\n   {\n      return data == in.data;\n   }\n   operator std::string()const\n   {\n      std::string tmp;\n      uint64_t tmp1 = data;\n      for(unsigned i = 0;i!=size;++i)\n      {\n         tmp+=tochar[tmp1 & 3];\n         tmp1 >>= 2;\n      }\n      std::reverse(tmp.begin(),tmp.end());\n      return tmp;\n   }\n   struct hash{\n   uint64_t operator()(const T& t)const{ return t.data; }\n   };\n   uint64_t data;\n   unsigned char size;\n};\n\n__gnu_pbds::cc_hash_table<T,unsigned,T::hash>\ncalculate(const std::string& input,unsigned size, unsigned beg=0,unsigned incr=1)\n{\n   __gnu_pbds::cc_hash_table<T,unsigned,T::hash> frequencies;\n   T tmp;\n   for (unsigned i = beg, i_end = input.size() + 1 - size; i < i_end; i+=incr)\n   {\n     tmp.reset(input,i,i+size);\n      ++frequencies[tmp];\n   }\n   return frequencies;\n}\n\n__gnu_pbds::cc_hash_table<T,unsigned,T::hash>\ntcalculate(const std::string& input,unsigned size)\n{\n   unsigned N = sysconf (_SC_NPROCESSORS_ONLN);\n\n   std::future<__gnu_pbds::cc_hash_table<T,unsigned,T::hash>> ft[N];\n   for(unsigned i = 0; i<N;++i)\n      ft[i] = std::async(std::launch::async,calculate,std::ref(input),size,i,N);\n\n   auto frequencies = ft[0].get();\n\n   for(unsigned i = 1 ; i<N; ++i)\n      for(auto& j : ft[i].get())\n      {\n         frequencies[j.first]+=j.second;\n      }\n   return frequencies;\n}\n\nvoid write_frequencies(const std::string & input, unsigned size)\n{\n   unsigned sum = input.size() + 1 - size;\n   auto frequencies = tcalculate(input,size);\n   std::map<unsigned, std::string,std::greater<unsigned>> freq;\n   for(auto& i: frequencies)\n   {\n      freq.insert(std::make_pair(i.second,i.first));\n   }\n   for(auto& i : freq)\n      std::cout << i.second << ' ' << (sum ? double(100 * i.first) / sum : 0.0) << '\\n';\n   std::cout << '\\n';\n}\n\nvoid write_count(const std::string & input, const std::string& string)\n{\n   unsigned size = string.size();\n   auto frequencies = tcalculate(input,size);\n\n   std::cout << frequencies[string] << '\\t' << string << '\\n';\n}\n\nint main()\n{\n   init();\n   std::string input;\n   char buffer[256];\n   while (fgets(buffer,100,stdin) && memcmp(\">THREE\",buffer,6)!=0);\n   while (fgets(buffer,100,stdin) && buffer[0] != '>')\n   {\n      if (buffer[0] != ';')\n      {\n         input.append(buffer,strlen(buffer)-1);\n      }\n   }\n   std::transform(input.begin(),input.end(),input.begin(),::toupper);\n\n   std::cout << std::setprecision(3) << std::setiosflags(std::ios::fixed);\n   write_frequencies(input,1);\n   write_frequencies(input,2);\n   write_count(input, \"GGT\");\n   write_count(input, \"GGTA\");\n   write_count(input, \"GGTATT\");\n   write_count(input, \"GGTATTTTAATT\");\n   write_count(input, \"GGTATTTTAATTTATAGT\");\n}",
        475.886,
        3677.832
    ],
    "1": [
        "#include <iostream>\n#include <iomanip>\n#include <cstdint>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#include <future>\n#include <unistd.h>\n#include <map>  // Correct the missing include for std::map\n\nunsigned char tonum[256], tochar[4];\n\nstatic void init() {\n   tonum['A'] = 0;\n   tonum['C'] = 1;\n   tonum['T'] = 2;\n   tonum['G'] = 3;\n   tochar[0] = 'A';\n   tochar[1] = 'C';\n   tochar[2] = 'T';\n   tochar[3] = 'G';\n}\n\nstruct T {\n   T(const std::string& s = std::string())\n   :data(0), size(s.size()) {\n      reset(s, 0, s.size());\n   }\n   void reset(const std::string& s, unsigned beg, unsigned end) {\n      size = end - beg;\n      data = 0;\n      for (unsigned i = beg; i != end; ++i) {\n         data <<= 2;\n         data |= tonum[unsigned(s[i])];\n      }\n   }\n   bool operator<(const T& in) const {\n      return data < in.data;\n   }\n   bool operator==(const T& in) const {\n      return data == in.data;\n   }\n   operator std::string() const {\n      std::string tmp;\n      uint64_t tmp1 = data;\n      for (unsigned i = 0; i != size; ++i) {\n         tmp += tochar[tmp1 & 3];\n         tmp1 >>= 2;\n      }\n      std::reverse(tmp.begin(), tmp.end());\n      return tmp;\n   }\n   struct hash {\n      uint64_t operator()(const T& t) const { return t.data; }\n   };\n   uint64_t data;\n   unsigned char size;\n};\n\nusing FrequencyMap = std::unordered_map<T, unsigned, T::hash>;\n\nFrequencyMap calculate(const std::string& input, unsigned size, unsigned beg = 0, unsigned incr = 1) {\n   FrequencyMap frequencies;\n   T tmp;\n   for (unsigned i = beg, i_end = input.size() + 1 - size; i < i_end; i += incr) {\n      tmp.reset(input, i, i + size);\n      ++frequencies[tmp];\n   }\n   return frequencies;\n}\n\nFrequencyMap tcalculate(const std::string& input, unsigned size) {\n   unsigned N = sysconf(_SC_NPROCESSORS_ONLN);\n\n   std::future<FrequencyMap> ft[N];\n   for (unsigned i = 0; i < N; ++i)\n      ft[i] = std::async(std::launch::async, calculate, std::ref(input), size, i, N);\n\n   auto frequencies = ft[0].get();\n\n   for (unsigned i = 1; i < N; ++i)\n      for (auto& j : ft[i].get()) {\n         frequencies[j.first] += j.second;\n      }\n   return frequencies;\n}\n\nvoid write_frequencies(const std::string & input, unsigned size) {\n   unsigned sum = input.size() + 1 - size;\n   auto frequencies = tcalculate(input, size);\n   std::map<unsigned, std::string, std::greater<unsigned>> freq;\n   for (auto& i : frequencies) {\n      freq.insert(std::make_pair(i.second, i.first));\n   }\n   for (auto& i : freq)\n      std::cout << i.second << ' ' << (sum ? double(100 * i.first) / sum : 0.0) << '\\n';\n   std::cout << '\\n';\n}\n\nvoid write_count(const std::string & input, const std::string& string) {\n   unsigned size = string.size();\n   auto frequencies = tcalculate(input, size);\n\n   std::cout << frequencies[string] << '\\t' << string << '\\n';\n}\n\nint main() {\n   init();\n   std::string input;\n   char buffer[256];\n   while (fgets(buffer, 100, stdin) && memcmp(\">THREE\", buffer, 6) != 0);\n   while (fgets(buffer, 100, stdin) && buffer[0] != '>') {\n      if (buffer[0] != ';') {\n         input.append(buffer, strlen(buffer)-1);\n      }\n   }\n   std::transform(input.begin(), input.end(), input.begin(), ::toupper);\n\n   std::cout << std::setprecision(3) << std::setiosflags(std::ios::fixed);\n   write_frequencies(input, 1);\n   write_frequencies(input, 2);\n   write_count(input, \"GGT\");\n   write_count(input, \"GGTA\");\n   write_count(input, \"GGTATT\");\n   write_count(input, \"GGTATTTTAATT\");\n   write_count(input, \"GGTATTTTAATTTATAGT\");\n}\n",
        751.795,
        5098.904
    ],
    "2": [
        "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <future>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <functional>\n#include <cstring>\n\nunsigned char tonum[256], tochar[4];\n\nstatic void init() {\n   for(int i = 0; i < 256; ++i) tonum[i] = 0; // Initialize all to zero\n   tonum['A'] = 0; tonum['C'] = 1; tonum['T'] = 2; tonum['G'] = 3;\n   tochar[0] = 'A'; tochar[1] = 'C'; tochar[2] = 'T'; tochar[3] = 'G';\n}\n\nclass ThreadPool {\n    public:\n        ThreadPool(size_t);\n        template<class F, class... Args>\n        auto enqueue(F&& f, Args&&... args) -> std::future<typename std::result_of<F(Args...)>::type>;\n        ~ThreadPool();\n    private:\n        std::vector<std::thread> workers;\n        std::queue<std::function<void()>> tasks;\n        std::mutex queue_mutex;\n        std::condition_variable condition;\n        bool stop;\n};\n\ninline ThreadPool::ThreadPool(size_t threads) : stop(false) {\n    for(size_t i = 0; i < threads; ++i) {\n        workers.emplace_back(\n            [this]\n            {\n                for(;;) {\n                    std::function<void()> task;\n                    {\n                        std::unique_lock<std::mutex> lock(this->queue_mutex);\n                        this->condition.wait(lock, [this]{ return this->stop || !this->tasks.empty(); });\n                        if(this->stop && this->tasks.empty())\n                            return;\n                        task = std::move(this->tasks.front());\n                        this->tasks.pop();\n                    }\n                    task();\n                }\n            }\n        );\n    }\n}\n\ninline ThreadPool::~ThreadPool() {\n    {\n        std::unique_lock<std::mutex> lock(queue_mutex);\n        stop = true;\n    }\n    condition.notify_all();\n    for(std::thread &worker: workers) {\n        if(worker.joinable())\n            worker.join();\n    }\n}\n\ntemplate<class F, class... Args>\nauto ThreadPool::enqueue(F&& f, Args&&... args) -> std::future<typename std::result_of<F(Args...)>::type> {\n    using return_type = typename std::result_of<F(Args...)>::type;\n    auto task = std::make_shared<std::packaged_task<return_type()>>(\n            std::bind(std::forward<F>(f), std::forward<Args>(args)...)\n        );\n    std::future<return_type> res = task->get_future();\n    {\n        std::unique_lock<std::mutex> lock(queue_mutex);\n        if(stop)\n            throw std::runtime_error(\"enqueue on stopped ThreadPool\");\n        tasks.emplace([task](){ (*task)(); });\n    }\n    condition.notify_one();\n    return res;\n}\n\nusing FrequencyMap = std::unordered_map<uint64_t, unsigned>;\n\nFrequencyMap calculate(const std::string& input, unsigned size, unsigned beg = 0, unsigned incr = 1) {\n   FrequencyMap frequencies;\n   for (size_t i = beg, i_end = input.size() + 1 - size; i < i_end; i += incr) {\n      uint64_t data = 0;\n      for(unsigned j = 0; j < size; ++j) {\n         data = (data << 2) | tonum[(unsigned char)input[i+j]];\n      }\n      ++frequencies[data];\n   }\n   return frequencies;\n}\n\nFrequencyMap parallel_calculate(const std::string& input, unsigned size, ThreadPool& pool) {\n   const unsigned N = std::thread::hardware_concurrency();\n   std::vector<std::future<FrequencyMap>> futures(N);\n   for (unsigned i = 0; i < N; ++i) {\n      futures[i] = pool.enqueue(calculate, input, size, i, N);\n   }\n\n   FrequencyMap result;\n   for (auto& future : futures) {\n      auto local_map = future.get();\n      for (const auto& kvp : local_map) {\n         result[kvp.first] += kvp.second;\n      }\n   }\n\n   return result;\n}\n\nvoid write_frequencies(const std::string & input, unsigned size, ThreadPool& pool) {\n   unsigned sum = input.size() + 1 - size;\n   const auto frequencies = parallel_calculate(input, size, pool);\n   std::vector<std::pair<unsigned, uint64_t>> sorted_frequencies;\n   for (const auto& kv : frequencies) {\n      sorted_frequencies.emplace_back(kv.second, kv.first);\n   }\n   std::sort(sorted_frequencies.rbegin(), sorted_frequencies.rend());\n\n   for (const auto& kv : sorted_frequencies) {\n      unsigned count = kv.first;\n      uint64_t data = kv.second;\n      std::string sequence(size, ' ');\n      for (int i = size - 1; i >= 0; --i) {\n         sequence[i] = tochar[data & 3];\n         data >>= 2;\n      }\n      std::cout << sequence << ' ' << std::fixed << std::setprecision(3) << double(100 * count) / sum << '\\n';\n   }\n   std::cout << '\\n';\n}\n\nvoid write_count(const std::string & input, const std::string& seq, ThreadPool& pool) {\n   unsigned size = seq.size();\n   auto frequencies = parallel_calculate(input, size, pool);\n   uint64_t data = 0;\n   for (char c : seq) {\n      data = (data << 2) | tonum[(unsigned char)c];\n   }\n   std::cout << frequencies[data] << '\\t' << seq << '\\n';\n}\n\nint main() {\n   init();\n   ThreadPool pool(std::thread::hardware_concurrency());\n   std::string input;\n   char buffer[256];\n   while (fgets(buffer, sizeof(buffer), stdin) && strncmp(\">THREE\", buffer, 6) != 0);\n   while (fgets(buffer, sizeof(buffer), stdin) && buffer[0] != '>') {\n      if (buffer[0] != ';') {\n         input.append(buffer, strlen(buffer) - 1);\n      }\n   }\n   std::transform(input.begin(), input.end(), input.begin(), ::toupper);\n\n   std::cout << std::setprecision(3) << std::fixed;\n   write_frequencies(input, 1, pool);\n   write_frequencies(input, 2, pool);\n   write_count(input, \"GGT\", pool);\n   write_count(input, \"GGTA\", pool);\n   write_count(input, \"GGTATT\", pool);\n   write_count(input, \"GGTATTTTAATT\", pool);\n   write_count(input, \"GGTATTTTAATTTATAGT\", pool);\n}",
        1550.552,
        15604.42
    ],
    "3": [
        "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <future>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <functional>\n#include <cstring>\n\nunsigned char tonum[256], tochar[4];\n\nstatic void init() {\n   for(int i = 0; i < 256; ++i) tonum[i] = 0; // Initialize all to zero\n   tonum['A'] = 0; tonum['C'] = 1; tonum['T'] = 2; tonum['G'] = 3;\n   tochar[0] = 'A'; tochar[1] = 'C'; tochar[2] = 'T'; tochar[3] = 'G';\n}\n\nclass ThreadPool {\n    public:\n        ThreadPool(size_t);\n        template<class F, class... Args>\n        auto enqueue(F&& f, Args&&... args) -> std::future<typename std::result_of<F(Args...)>::type>;\n        ~ThreadPool();\n    private:\n        std::vector<std::thread> workers;\n        std::queue<std::function<void()>> tasks;\n        std::mutex queue_mutex;\n        std::condition_variable condition;\n        bool stop;\n};\n\ninline ThreadPool::ThreadPool(size_t threads) : stop(false) {\n    for(size_t i = 0; i < threads; ++i) {\n        workers.emplace_back(\n            [this]\n            {\n                for(;;) {\n                    std::function<void()> task;\n                    {\n                        std::unique_lock<std::mutex> lock(this->queue_mutex);\n                        this->condition.wait(lock, [this]{ return this->stop || !this->tasks.empty(); });\n                        if(this->stop && this->tasks.empty())\n                            return;\n                        task = std::move(this->tasks.front());\n                        this->tasks.pop();\n                    }\n                    task();\n                }\n            }\n        );\n    }\n}\n\ninline ThreadPool::~ThreadPool() {\n    {\n        std::unique_lock<std::mutex> lock(queue_mutex);\n        stop = true;\n    }\n    condition.notify_all();\n    for(std::thread &worker: workers) {\n        if(worker.joinable())\n            worker.join();\n    }\n}\n\ntemplate<class F, class... Args>\nauto ThreadPool::enqueue(F&& f, Args&&... args) -> std::future<typename std::result_of<F(Args...)>::type> {\n    using return_type = typename std::result_of<F(Args...)>::type;\n    auto task = std::make_shared<std::packaged_task<return_type()>>(\n            std::bind(std::forward<F>(f), std::forward<Args>(args)...)\n        );\n    std::future<return_type> res = task->get_future();\n    {\n        std::unique_lock<std::mutex> lock(queue_mutex);\n        if(stop)\n            throw std::runtime_error(\"enqueue on stopped ThreadPool\");\n        tasks.emplace([task](){ (*task)(); });\n    }\n    condition.notify_one();\n    return res;\n}\n\nusing FrequencyMap = std::unordered_map<uint64_t, unsigned>;\n\nFrequencyMap calculate(const std::string& input, unsigned size, unsigned beg = 0, unsigned incr = 1) {\n   FrequencyMap frequencies;\n   for (size_t i = beg, i_end = input.size() + 1 - size; i < i_end; i += incr) {\n      uint64_t data = 0;\n      for(unsigned j = 0; j < size; ++j) {\n         data = (data << 2) | tonum[(unsigned char)input[i+j]];\n      }\n      ++frequencies[data];\n   }\n   return frequencies;\n}\n\nFrequencyMap parallel_calculate(const std::string& input, unsigned size, ThreadPool& pool) {\n   const unsigned N = std::thread::hardware_concurrency();\n   std::vector<std::future<FrequencyMap>> futures(N);\n   for (unsigned i = 0; i < N; ++i) {\n      futures[i] = pool.enqueue(calculate, input, size, i, N);\n   }\n\n   FrequencyMap result;\n   for (auto& future : futures) {\n      auto local_map = future.get();\n      for (const auto& kvp : local_map) {\n         result[kvp.first] += kvp.second;\n      }\n   }\n\n   return result;\n}\n\nvoid write_frequencies(const std::string & input, unsigned size, ThreadPool& pool) {\n   unsigned sum = input.size() + 1 - size;\n   const auto frequencies = parallel_calculate(input, size, pool);\n   std::vector<std::pair<unsigned, uint64_t>> sorted_frequencies;\n   for (const auto& kv : frequencies) {\n      sorted_frequencies.emplace_back(kv.second, kv.first);\n   }\n   std::sort(sorted_frequencies.rbegin(), sorted_frequencies.rend());\n\n   for (const auto& kv : sorted_frequencies) {\n      unsigned count = kv.first;\n      uint64_t data = kv.second;\n      std::string sequence(size, ' ');\n      for (int i = size - 1; i >= 0; --i) {\n         sequence[i] = tochar[data & 3];\n         data >>= 2;\n      }\n      std::cout << sequence << ' ' << std::fixed << std::setprecision(3) << double(100 * count) / sum << '\\n';\n   }\n   std::cout << '\\n';\n}\n\nvoid write_count(const std::string & input, const std::string& seq, ThreadPool& pool) {\n   unsigned size = seq.size();\n   auto frequencies = parallel_calculate(input, size, pool);\n   uint64_t data = 0;\n   for (char c : seq) {\n      data = (data << 2) | tonum[(unsigned char)c];\n   }\n   std::cout << frequencies[data] << '\\t' << seq << '\\n';\n}\n\nint main() {\n   init();\n   ThreadPool pool(std::thread::hardware_concurrency());\n   std::string input;\n   char buffer[256];\n   while (fgets(buffer, sizeof(buffer), stdin) && strncmp(\">THREE\", buffer, 6) != 0);\n   while (fgets(buffer, sizeof(buffer), stdin) && buffer[0] != '>') {\n      if (buffer[0] != ';') {\n         input.append(buffer, strlen(buffer) - 1);\n      }\n   }\n   std::transform(input.begin(), input.end(), input.begin(), ::toupper);\n\n   std::cout << std::setprecision(3) << std::fixed;\n   write_frequencies(input, 1, pool);\n   write_frequencies(input, 2, pool);\n   write_count(input, \"GGT\", pool);\n   write_count(input, \"GGTA\", pool);\n   write_count(input, \"GGTATT\", pool);\n   write_count(input, \"GGTATTTTAATT\", pool);\n   write_count(input, \"GGTATTTTAATTTATAGT\", pool);\n}",
        1551.887,
        15559.98
    ],
    "4": [
        "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <future>\n#include <unordered_map>\n#include <algorithm>\n#include <thread>\n#include <cstring>\n#include <vector>\n\nusing FrequencyMap = std::unordered_map<uint64_t, unsigned>;\n\nstatic unsigned char tonum[256], tochar[4];\n\nstatic void init() {\n    std::fill(std::begin(tonum), std::end(tonum), 0);\n    tonum['A'] = 0; tonum['C'] = 1; tonum['T'] = 2; tonum['G'] = 3;\n    tochar[0] = 'A'; tochar[1] = 'C'; tochar[2] = 'T'; tochar[3] = 'G';\n}\n\nFrequencyMap calculate(const std::string& input, unsigned size, unsigned beg = 0, unsigned incr = 1) {\n    FrequencyMap frequencies;\n    frequencies.reserve(2000);\n    for (size_t i = beg, i_end = input.size() + 1 - size; i < i_end; i += incr) {\n        uint64_t data = 0;\n        for(unsigned j = 0; j < size; ++j) {\n            data = (data << 2) | tonum[(unsigned char)input[i + j]];\n        }\n        ++frequencies[data];\n    }\n    return frequencies;\n}\n\nstd::string num_to_sequence(uint64_t data, unsigned length) {\n    std::string sequence;\n    sequence.reserve(length);\n    for (unsigned i = 0; i < length; ++i) {\n        sequence.push_back(tochar[data & 3]);\n        data >>= 2;\n    }\n    std::reverse(sequence.begin(), sequence.end());\n    return sequence;\n}\n\nvoid write_frequencies(const FrequencyMap& frequency_map, unsigned total, unsigned seq_length) {\n    std::vector<std::pair<unsigned, uint64_t>> sorted_frequencies;\n    sorted_frequencies.reserve(frequency_map.size());\n    for (const auto& item : frequency_map) {\n        if (item.second > 0) // Only include non-zero frequencies\n            sorted_frequencies.emplace_back(item.second, item.first);\n    }\n    // Sort by frequency then sequence\n    std::sort(sorted_frequencies.begin(), sorted_frequencies.end(), [](const auto& a, const auto& b) {\n        return a.first > b.first || (a.first == b.first && a.second < b.second);\n    });\n    // Output sequences and frequencies\n    for (const auto& kv : sorted_frequencies) {\n        unsigned count = kv.first;\n        std::string sequence = num_to_sequence(kv.second, seq_length);  // provide correct sequence lengths\n        std::cout << sequence << ' ' << std::fixed << std::setprecision(3) << double(100 * count) / total << '\\n';\n    }\n    std::cout << '\\n';\n}\n\nvoid write_frequency_distribution(const std::string& input, unsigned size) {\n    const auto max_threads = std::thread::hardware_concurrency();\n    std::vector<std::future<FrequencyMap>> futures(max_threads);\n    \n    for (unsigned i = 0; i < max_threads; ++i) {\n        futures[i] = std::async(std::launch::async, calculate, std::ref(input), size, i, max_threads);\n    }\n\n    FrequencyMap frequency_map;\n    frequency_map.reserve(2000);\n    for (auto& future : futures) {\n        auto local_map = future.get();\n        for (const auto& kvp : local_map) {\n            frequency_map[kvp.first] += kvp.second;\n        }\n    }\n\n    write_frequencies(frequency_map, input.size() + 1 - size, size);\n}\n\nvoid write_count(const std::string& input, const std::string& seq) {\n    unsigned size = seq.size();\n    auto frequencies = calculate(input, size);\n    uint64_t data = 0;\n    for (char c : seq) {\n        data = (data << 2) | tonum[(unsigned char)c];\n    }\n    std::cout << frequencies[data] << \"\\t\" << seq << '\\n';\n}\n\nint main() {\n    init();\n    std::string input;\n    char buffer[256];\n    while (fgets(buffer, sizeof(buffer), stdin) && strncmp(\">THREE\", buffer, 6) != 0);\n    while (fgets(buffer, sizeof(buffer), stdin) && buffer[0] != '>') {\n        if (buffer[0] != ';') {\n            size_t len = strlen(buffer);\n            if (len > 0 && buffer[len - 1] == '\\n') buffer[--len] = 0;\n            input.append(buffer);\n        }\n    }\n    std::transform(input.begin(), input.end(), input.begin(), ::toupper);\n\n    std::cout << std::setprecision(3) << std::fixed;\n    write_frequency_distribution(input, 1);\n    write_frequency_distribution(input, 2);\n    write_count(input, \"GGT\");\n    write_count(input, \"GGTA\");\n    write_count(input, \"GGTATT\");\n    write_count(input, \"GGTATTTTAATT\");\n    write_count(input, \"GGTATTTTAATTTATAGT\");\n    return 0;\n}",
        -49556.531,
        53580.0
    ],
    "5": [
        "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <future>\n#include <unordered_map>\n#include <algorithm>\n#include <thread>\n#include <cstring>\n#include <vector>\n\nusing FrequencyMap = std::unordered_map<uint64_t, unsigned>;\n\nstatic unsigned char tonum[256], tochar[4];\n\nstatic void init() {\n    std::fill(std::begin(tonum), std::end(tonum), 0);\n    tonum['A'] = 0; tonum['C'] = 1; tonum['T'] = 2; tonum['G'] = 3;\n    tochar[0] = 'A'; tochar[1] = 'C'; tochar[2] = 'T'; tochar[3] = 'G';\n}\n\nFrequencyMap calculate(const std::string& input, unsigned size, unsigned beg = 0, unsigned incr = 1) {\n    FrequencyMap frequencies;\n    frequencies.reserve(2000);\n    for (size_t i = beg, i_end = input.size() + 1 - size; i < i_end; i += incr) {\n        uint64_t data = 0;\n        for(unsigned j = 0; j < size; ++j) {\n            data = (data << 2) | tonum[(unsigned char)input[i + j]];\n        }\n        ++frequencies[data];\n    }\n    return frequencies;\n}\n\nstd::string num_to_sequence(uint64_t data, unsigned length) {\n    std::string sequence;\n    sequence.reserve(length);\n    for (unsigned i = 0; i < length; ++i) {\n        sequence.push_back(tochar[data & 3]);\n        data >>= 2;\n    }\n    std::reverse(sequence.begin(), sequence.end());\n    return sequence;\n}\n\nvoid write_frequencies(const FrequencyMap& frequency_map, unsigned total, unsigned seq_length) {\n    std::vector<std::pair<unsigned, uint64_t>> sorted_frequencies;\n    sorted_frequencies.reserve(frequency_map.size());\n    for (const auto& item : frequency_map) {\n        if (item.second > 0) {\n            sorted_frequencies.emplace_back(item.second, item.first);\n        }\n    }\n    std::sort(sorted_frequencies.begin(), sorted_frequencies.end(), [](const auto& a, const auto& b) {\n        return a.first > b.first || (a.first == b.first && a.second < b.second);\n    });\n    for (const auto& kv : sorted_frequencies) {\n        unsigned count = kv.first;\n        std::string sequence = num_to_sequence(kv.second, seq_length);\n        std::cout << sequence << ' ' << std::fixed << std::setprecision(3) << double(100 * count) / total << '\\n';\n    }\n    std::cout << '\\n';\n}\n\nvoid write_frequency_distribution(const std::string& input, unsigned size) {\n    const auto max_threads = std::thread::hardware_concurrency();\n    std::vector<std::future<FrequencyMap>> futures(max_threads);\n    \n    for (unsigned i = 0; i < max_threads; ++i) {\n        futures[i] = std::async(std::launch::async, calculate, std::ref(input), size, i, max_threads);\n    }\n\n    FrequencyMap frequency_map;\n    frequency_map.reserve(2000);\n    for (auto& future : futures) {\n        auto local_map = future.get();\n        for (const auto& kvp : local_map) {\n            frequency_map[kvp.first] += kvp.second;\n        }\n    }\n\n    write_frequencies(frequency_map, input.size() + 1 - size, size);\n}\n\nvoid write_count(const std::string& input, const std::string& seq) {\n    unsigned size = seq.size();\n    auto frequencies = calculate(input, size);\n    uint64_t data = 0;\n    for (char c : seq) {\n        data = (data << 2) | tonum[(unsigned char)c];\n    }\n    std::cout << frequencies[data] << \"\\t\" << seq << '\\n';\n}\n\nint main() {\n    init();\n    std::string input;\n    char buffer[256];\n    while (fgets(buffer, sizeof(buffer), stdin) && strncmp(\">THREE\", buffer, 6) != 0);\n    while (fgets(buffer, sizeof(buffer), stdin) && buffer[0] != '>') {\n        if (buffer[0] != ';') {\n            size_t len = strlen(buffer);\n            if (len > 0 && buffer[len - 1] == '\\n') buffer[--len] = 0;\n            input.append(buffer);\n        }\n    }\n    std::transform(input.begin(), input.end(), input.begin(), ::toupper);\n\n    std::cout << std::setprecision(3) << std::fixed;\n    write_frequency_distribution(input, 1);\n    write_frequency_distribution(input, 2);\n    write_count(input, \"GGT\");\n    write_count(input, \"GGTA\");\n    write_count(input, \"GGTATT\");\n    write_count(input, \"GGTATTTTAATT\");\n    write_count(input, \"GGTATTTTAATTTATAGT\");\n    return 0;\n}",
        2874.514,
        53643.34
    ]
}

Program executed for 26.444097 minutes