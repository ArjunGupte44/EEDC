{
    "0": [
        "// g++ 4.8.x bug, compile with: -Wl,--no-as-needed option \n\n#include <iostream>\n#include <iomanip>\n#include <cstdint>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <future>\n#include <unistd.h>\n\nunsigned char tonum[256],tochar[4];\nstatic void init()\n{\n   tonum['A'] = 0;\n   tonum['C'] = 1;\n   tonum['T'] = 2;\n   tonum['G'] = 3;\n   tochar[0] = 'A';\n   tochar[1] = 'C';\n   tochar[2] = 'T';\n   tochar[3] = 'G';\n}\n\nstruct T{\n   T(const std::string& s = std::string())\n   :data(0),size(s.size())\n   {\n      reset(s,0,s.size());\n   }\n   void reset(const std::string& s,unsigned beg,unsigned end)\n   {\n      size = end-beg;\n      data = 0;\n      for(unsigned i = beg; i != end; ++i)\n      {\n         data <<= 2;\n         data |= tonum[unsigned(s[i])];\n      }\n   }\n   bool operator<(const T& in)const\n   {\n      return data < in.data;\n   }\n   bool operator==(const T& in)const\n   {\n      return data == in.data;\n   }\n   operator std::string()const\n   {\n      std::string tmp;\n      uint64_t tmp1 = data;\n      for(unsigned i = 0;i!=size;++i)\n      {\n         tmp+=tochar[tmp1 & 3];\n         tmp1 >>= 2;\n      }\n      std::reverse(tmp.begin(),tmp.end());\n      return tmp;\n   }\n   struct hash{\n   uint64_t operator()(const T& t)const{ return t.data; }\n   };\n   uint64_t data;\n   unsigned char size;\n};\n\n__gnu_pbds::cc_hash_table<T,unsigned,T::hash>\ncalculate(const std::string& input,unsigned size, unsigned beg=0,unsigned incr=1)\n{\n   __gnu_pbds::cc_hash_table<T,unsigned,T::hash> frequencies;\n   T tmp;\n   for (unsigned i = beg, i_end = input.size() + 1 - size; i < i_end; i+=incr)\n   {\n     tmp.reset(input,i,i+size);\n      ++frequencies[tmp];\n   }\n   return frequencies;\n}\n\n__gnu_pbds::cc_hash_table<T,unsigned,T::hash>\ntcalculate(const std::string& input,unsigned size)\n{\n   unsigned N = sysconf (_SC_NPROCESSORS_ONLN);\n\n   std::future<__gnu_pbds::cc_hash_table<T,unsigned,T::hash>> ft[N];\n   for(unsigned i = 0; i<N;++i)\n      ft[i] = std::async(std::launch::async,calculate,std::ref(input),size,i,N);\n\n   auto frequencies = ft[0].get();\n\n   for(unsigned i = 1 ; i<N; ++i)\n      for(auto& j : ft[i].get())\n      {\n         frequencies[j.first]+=j.second;\n      }\n   return frequencies;\n}\n\nvoid write_frequencies(const std::string & input, unsigned size)\n{\n   unsigned sum = input.size() + 1 - size;\n   auto frequencies = tcalculate(input,size);\n   std::map<unsigned, std::string,std::greater<unsigned>> freq;\n   for(auto& i: frequencies)\n   {\n      freq.insert(std::make_pair(i.second,i.first));\n   }\n   for(auto& i : freq)\n      std::cout << i.second << ' ' << (sum ? double(100 * i.first) / sum : 0.0) << '\\n';\n   std::cout << '\\n';\n}\n\nvoid write_count(const std::string & input, const std::string& string)\n{\n   unsigned size = string.size();\n   auto frequencies = tcalculate(input,size);\n\n   std::cout << frequencies[string] << '\\t' << string << '\\n';\n}\n\nint main()\n{\n   init();\n   std::string input;\n   char buffer[256];\n   while (fgets(buffer,100,stdin) && memcmp(\">THREE\",buffer,6)!=0);\n   while (fgets(buffer,100,stdin) && buffer[0] != '>')\n   {\n      if (buffer[0] != ';')\n      {\n         input.append(buffer,strlen(buffer)-1);\n      }\n   }\n   std::transform(input.begin(),input.end(),input.begin(),::toupper);\n\n   std::cout << std::setprecision(3) << std::setiosflags(std::ios::fixed);\n   write_frequencies(input,1);\n   write_frequencies(input,2);\n   write_count(input, \"GGT\");\n   write_count(input, \"GGTA\");\n   write_count(input, \"GGTATT\");\n   write_count(input, \"GGTATTTTAATT\");\n   write_count(input, \"GGTATTTTAATTTATAGT\");\n}",
        476.992,
        3689.24
    ],
    "1": [
        "#include <iostream>\n#include <iomanip>\n#include <cstdint>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#include <future>\n#include <unistd.h>\n#include <vector>\n#include <map>\n\nunsigned char tonum[256],tochar[4];\nstatic void init()\n{\n   tonum['A'] = 0;\n   tonum['C'] = 1;\n   tonum['T'] = 2;\n   tonum['G'] = 3;\n   tochar[0] = 'A';\n   tochar[1] = 'C';\n   tochar[2] = 'T';\n   tochar[3] = 'G';\n}\n\nstruct T{\n   T(const std::string& s = std::string())\n   :data(0),size(s.size())\n   {\n      reset(s,0,s.size());\n   }\n   void reset(const std::string& s,unsigned beg,unsigned end)\n   {\n      size = end-beg;\n      data = 0;\n      for(unsigned i = beg; i != end; ++i)\n      {\n         data <<= 2;\n         data |= tonum[unsigned(s[i])];\n      }\n   }\n   bool operator<(const T& in)const\n   {\n      return data < in.data;\n   }\n   bool operator==(const T& in)const\n   {\n      return data == in.data;\n   }\n   operator std::string()const\n   {\n      std::string tmp;\n      uint64_t tmp1 = data;\n      for(unsigned i = 0;i!=size;++i)\n      {\n         tmp+=tochar[tmp1 & 3];\n         tmp1 >>= 2;\n      }\n      std::reverse(tmp.begin(),tmp.end());\n      return tmp;\n   }\n   struct hash{\n   uint64_t operator()(const T& t)const{ return t.data; }\n   };\n   uint64_t data;\n   unsigned char size;\n};\n\nstd::unordered_map<T, unsigned, T::hash> \ncalculate(const std::string& input, unsigned size, unsigned beg=0, unsigned incr=1)\n{\n   std::unordered_map<T, unsigned, T::hash> frequencies;\n   T tmp;\n   for (unsigned i = beg, i_end = input.size() + 1 - size; i < i_end; i+=incr)\n   {\n     tmp.reset(input,i,i+size);\n      ++frequencies[tmp];\n   }\n   return frequencies;\n}\n\nstd::unordered_map<T, unsigned, T::hash> \ntcalculate(const std::string& input, unsigned size)\n{\n   unsigned N = std::max((unsigned)1, static_cast<unsigned>(sysconf (_SC_NPROCESSORS_ONLN)));\n   std::vector<std::future<std::unordered_map<T, unsigned, T::hash>>> futures(N);\n   for(unsigned i = 0; i<N;++i)\n      futures[i] = std::async(std::launch::async,calculate,std::ref(input),size,i,N);\n\n   std::unordered_map<T, unsigned, T::hash> frequencies;\n   for(unsigned i = 0; i<N; ++i)\n   {\n      auto result = futures[i].get();\n      for(auto& j : result)\n      {\n         frequencies[j.first]+=j.second;\n      }\n   }\n   return frequencies;\n}\n\nvoid write_frequencies(const std::string & input, unsigned size)\n{\n   unsigned sum = input.size() + 1 - size;\n   auto frequencies = tcalculate(input,size);\n   std::map<unsigned, std::string,std::greater<unsigned>> freq;\n   for(auto& i: frequencies)\n   {\n      freq.insert(std::make_pair(i.second,i.first));\n   }\n   for(auto& i : freq)\n      std::cout << i.second << ' ' << (sum ? double(100 * i.first) / sum : 0.0) << '\\n';\n   std::cout << '\\n';\n}\n\nvoid write_count(const std::string & input, const std::string& string)\n{\n   unsigned size = string.size();\n   auto frequencies = tcalculate(input,size);\n   std::cout << frequencies[string] << '\\t' << string << '\\n';\n}\n\nint main()\n{\n   init();\n   std::string input;\n   char buffer[256];\n   while (fgets(buffer,100,stdin) && memcmp(\">THREE\",buffer,6)!=0);\n   while (fgets(buffer,100,stdin) && buffer[0] != '>')\n   {\n      if (buffer[0] != ';')\n      {\n         input.append(buffer,strlen(buffer)-1);\n      }\n   }\n   std::transform(input.begin(),input.end(),input.begin(),::toupper);\n\n   std::cout << std::setprecision(3) << std::setiosflags(std::ios::fixed);\n   write_frequencies(input,1);\n   write_frequencies(input,2);\n   write_count(input, \"GGT\");\n   write_count(input, \"GGTA\");\n   write_count(input, \"GGTATT\");\n   write_count(input, \"GGTATTTTAATT\");\n   write_count(input, \"GGTATTTTAATTTATAGT\");\n}",
        716.233,
        4890.354
    ],
    "2": [
        "#include <iostream>\n#include <iomanip>\n#include <cstdint>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#include <thread>\n#include <vector>\n#include <map>\n\nunsigned char tonum[256], tochar[4];\nstatic void init() {\n    tonum['A'] = 0;\n    tonum['C'] = 1;\n    tonum['T'] = 2;\n    tonum['G'] = 3;\n    tochar[0] = 'A';\n    tochar[1] = 'C';\n    tochar[2] = 'T';\n    tochar[3] = 'G';\n}\n\nstruct T {\n    T(const std::string& s = std::string())\n        : data(0), size(s.size()) {\n        reset(s, 0, s.size());\n    }\n    void reset(const std::string& s, unsigned beg, unsigned end) {\n        size = end - beg;\n        data = 0;\n        for (unsigned i = beg; i != end; ++i) {\n            data <<= 2;\n            data |= tonum[unsigned(s[i])];\n        }\n    }\n    bool operator<(const T& in) const {\n        return data < in.data;\n    }\n    bool operator==(const T& in) const {\n        return data == in.data;\n    }\n    operator std::string() const {\n        std::string tmp;\n        uint64_t tmp1 = data;\n        for (unsigned i = 0; i != size; ++i) {\n            tmp += tochar[tmp1 & 3];\n            tmp1 >>= 2;\n        }\n        std::reverse(tmp.begin(), tmp.end());\n        return tmp;\n    }\n    struct hash {\n        uint64_t operator()(const T& t) const { return t.data; }\n    };\n    uint64_t data;\n    unsigned char size;\n};\n\nstd::map<T, unsigned> calculate_optimized(const std::string& input, unsigned size, unsigned beg = 0, unsigned incr = 1) {\n    std::map<T, unsigned> frequencies;\n    T tmp;\n    for (unsigned i = beg, i_end = input.size() + 1 - size; i < i_end; i += incr) {\n        tmp.reset(input, i, i + size);\n        ++frequencies[tmp];\n    }\n    return frequencies;\n}\n\nstd::map<T, unsigned> tcalculate_optimized(const std::string& input, unsigned size) {\n    unsigned num_threads = std::thread::hardware_concurrency();\n    if (num_threads == 0) num_threads = 1; // Default to 1 if unable to detect\n    std::vector<std::thread> workers;\n    std::vector<std::map<T, unsigned>> thread_results(num_threads);\n\n    for (unsigned i = 0; i < num_threads; ++i) {\n        workers.emplace_back([&](int index) {\n            thread_results[index] = calculate_optimized(input, size, index, num_threads);\n        }, i);\n    }\n\n    for (auto& worker : workers) {\n        worker.join();\n    }\n\n    std::map<T, unsigned> frequencies;\n    for (auto& result : thread_results) {\n        for (auto& entry : result) {\n            frequencies[entry.first] += entry.second;\n        }\n    }\n\n    return frequencies;\n}\n\nvoid write_frequencies(const std::string& input, unsigned size) {\n    unsigned sum = input.size() + 1 - size;\n    auto frequencies = tcalculate_optimized(input, size);\n    std::map<unsigned, std::string, std::greater<>> freq;\n    for (auto& i : frequencies) {\n        freq[i.second] = i.first;\n    }\n    for (auto& i : freq) {\n        std::cout << i.second << ' ' << (sum ? double(100 * i.first) / sum : 0.0) << '\\n';\n    }\n    std::cout << '\\n';\n}\n\nvoid write_count(const std::string& input, const std::string& string) {\n    unsigned size = string.size();\n    auto frequencies = tcalculate_optimized(input, size);\n    std::cout << frequencies[string] << '\\t' << string << '\\n';\n}\n\nint main() {\n    init();\n    std::string input;\n    char buffer[256];\n    while (fgets(buffer, sizeof(buffer), stdin) && memcmp(\">THREE\", buffer, 6) != 0);\n    while (fgets(buffer, sizeof(buffer), stdin) && buffer[0] != '>') {\n        if (buffer[0] != ';') {\n            input.append(buffer, strlen(buffer) - 1);\n        }\n    }\n    std::transform(input.begin(), input.end(), input.begin(), ::toupper);\n\n    std::cout << std::setprecision(3) << std::setiosflags(std::ios::fixed);\n    write_frequencies(input, 1);\n    write_frequencies(input, 2);\n    write_count(input, \"GGT\");\n    write_count(input, \"GGTA\");\n    write_count(input, \"GGTATT\");\n    write_count(input, \"GGTATTTTAATT\");\n    write_count(input, \"GGTATTTTAATTTATAGT\");\n}",
        1588.69,
        9873.786
    ],
    "3": [
        "#include <iostream>\n#include <iomanip>\n#include <cstdint>\n#include <string>\n#include <unordered_map>\n#include <thread>\n#include <vector>\n#include <sstream>\n#include <cstring>  // Required for memcmp, strlen\n#include <algorithm> // Required for std::transform\n\nunsigned char tonum[256], tochar[4];\n\nstatic void init() {\n    std::fill(std::begin(tonum), std::end(tonum), 0);  // clear the array\n    tonum['A'] = 0;\n    tonum['C'] = 1;\n    tonum['T'] = 2;\n    tonum['G'] = 3;\n    tochar[0] = 'A';\n    tochar[1] = 'C';\n    tochar[2] = 'T';\n    tochar[3] = 'G';\n}\n\nstruct T {\n    uint64_t data;\n    unsigned size;\n    T(const std::string& str = \"\") : data(0), size(str.size()) {\n        reset(str, 0, size);\n    }\n    void reset(const std::string& str, unsigned beg, unsigned end) {\n        data = 0;\n        size = end - beg;\n        for (unsigned i = beg; i < end; ++i) {\n            data <<= 2;\n            data |= tonum[(unsigned char)str[i]];\n        }\n    }\n    bool operator==(const T& other) const { return data == other.data; }\n    std::string toString() const {\n        std::string result;\n        uint64_t temp = data;\n        for (unsigned i = 0; i < size; ++i) {\n            result.insert(result.begin(), tochar[temp & 3]);\n            temp >>= 2;\n        }\n        return result;\n    }\n    struct Hash {\n        std::size_t operator()(const T& t) const { return t.data; }\n    };\n};\n\nusing FrequencyMap = std::unordered_map<T, unsigned, T::Hash>;\n\nFrequencyMap calculate_optimized(const std::string& input, unsigned size, unsigned start, unsigned step) {\n    FrequencyMap frequencies;\n    for (unsigned i = start, i_end = input.size() + 1 - size; i < i_end; i += step) {\n        T tmp(input.substr(i, size));\n        ++frequencies[tmp];\n    }\n    return frequencies;\n}\n\nFrequencyMap tcalculate_optimized(const std::string& input, unsigned size) {\n    unsigned num_threads = std::max(1u, std::thread::hardware_concurrency());\n    std::vector<std::thread> workers;\n    std::vector<FrequencyMap> thread_results(num_threads);\n\n    for (unsigned i = 0; i < num_threads; ++i) {\n        workers.emplace_back([&, i]() {\n            thread_results[i] = calculate_optimized(input, size, i, num_threads);\n        });\n    }\n\n    for (auto& worker : workers) {\n        worker.join();\n    }\n\n    FrequencyMap frequencies;\n    for (const auto& result : thread_results) {\n        for (const auto& entry : result) {\n            frequencies[entry.first] += entry.second;\n        }\n    }\n    return frequencies;\n}\n\nvoid write_frequencies(const std::string& input, unsigned size) {\n    unsigned sum = input.size() + 1 - size;\n    auto frequencies = tcalculate_optimized(input, size);\n    std::unordered_map<unsigned, std::string> freq;\n\n    // Collect results into a vector for sorting\n    std::vector<std::pair<std::string, unsigned>> results;\n    for (const auto& i : frequencies) {\n        results.emplace_back(i.first.toString(), i.second);\n    }\n\n    // Sort the results by frequency and lexicographically\n    std::sort(results.begin(), results.end(), [](const std::pair<std::string, unsigned>& a, const std::pair<std::string, unsigned>& b) {\n        if (a.second != b.second)\n            return a.second > b.second;  // descending frequency\n        return a.first < b.first;       // ascending lexicographical order\n    });\n\n    // Print sorted results\n    for (const auto& i : results) {\n        std::cout << i.first << ' ' << (sum ? 100.0 * i.second / sum : 0.0) << '\\n';\n    }\n    std::cout << '\\n';\n}\n\nvoid write_count(const std::string& input, const std::string& str) {\n    auto frequencies = tcalculate_optimized(input, str.length());\n    std::cout << frequencies[T(str)] << '\\t' << str << '\\n';\n}\n\nint main() {\n    init();\n    std::string input;\n    char buffer[256];\n\n    while (fgets(buffer, sizeof(buffer), stdin) && memcmp(\">THREE\", buffer, 6) != 0);\n    while (fgets(buffer, sizeof(buffer), stdin) && buffer[0] != '>') {\n        if (buffer[0] != ';') {\n            input.append(buffer, strlen(buffer) - 1);\n        }\n    }\n    std::transform(input.begin(), input.end(), input.begin(), ::toupper);\n\n    std::cout << std::setprecision(3) << std::fixed;\n    write_frequencies(input, 1);\n    write_frequencies(input, 2);\n    write_count(input, \"GGT\");\n    write_count(input, \"GGTA\");\n    write_count(input, \"GGTATT\");\n    write_count(input, \"GGTATTTTAATT\");\n    write_count(input, \"GGTATTTTAATTTATAGT\");\n}",
        909.273,
        5971.244
    ],
    "4": [
        "#include <iostream>\n#include <iomanip>\n#include <cstdint>\n#include <string>\n#include <unordered_map>\n#include <thread>\n#include <vector>\n#include <sstream>\n#include <cstring>  // Required for memcmp, strlen\n#include <algorithm> // Required for std::transform\n\nunsigned char tonum[256], tochar[4];\n\nstatic void init() {\n    std::fill(std::begin(tonum), std::end(tonum), 0);  // clear the array\n    tonum['A'] = 0;\n    tonum['C'] = 1;\n    tonum['T'] = 2;\n    tonum['G'] = 3;\n    tochar[0] = 'A';\n    tochar[1] = 'C';\n    tochar[2] = 'T';\n    tochar[3] = 'G';\n}\n\nstruct T {\n    uint64_t data;\n    unsigned size;\n    T(const std::string& str = \"\") : data(0), size(str.size()) {\n        reset(str, 0, size);\n    }\n    void reset(const std::string& str, unsigned beg, unsigned end) {\n        data = 0;\n        size = end - beg;\n        for (unsigned i = beg; i < end; ++i) {\n            data <<= 2;\n            data |= tonum[(unsigned char)str[i]];\n        }\n    }\n    bool operator==(const T& other) const { return data == other.data; }\n    std::string toString() const {\n        std::string result;\n        uint64_t temp = data;\n        for (unsigned i = 0; i < size; ++i) {\n            result.insert(result.begin(), tochar[temp & 3]);\n            temp >>= 2;\n        }\n        return result;\n    }\n    struct Hash {\n        std::size_t operator()(const T& t) const { return t.data; }\n    };\n};\n\nusing FrequencyMap = std::unordered_map<T, unsigned, T::Hash>;\n\nFrequencyMap calculate_optimized(const std::string& input, unsigned size, unsigned start, unsigned step) {\n    FrequencyMap frequencies;\n    T tmp;\n    for (unsigned i = start, i_end = input.size() + 1 - size; i < i_end; i += step) {\n        tmp.reset(input, i, i + size);  // Avoid making substrings\n        ++frequencies[tmp];\n    }\n    return frequencies;\n}\n\nFrequencyMap tcalculate_optimized(const std::string& input, unsigned size) {\n    unsigned num_threads = std::max(1u, std::thread::hardware_concurrency());\n    std::vector<std::thread> workers;\n    std::vector<FrequencyMap> thread_results(num_threads);\n\n    for (unsigned i = 0; i < num_threads; ++i) {\n        workers.emplace_back([&, i]() {\n            thread_results[i] = calculate_optimized(input, size, i, num_threads);\n        });\n    }\n\n    for (auto& worker : workers) {\n        worker.join();\n    }\n\n    FrequencyMap frequencies;\n    for (const auto& result : thread_results) {\n        for (const auto& entry : result) {\n            frequencies[entry.first] += entry.second;\n        }\n    }\n    return frequencies;\n}\n\nvoid write_frequencies(const std::string& input, unsigned size) {\n    unsigned sum = input.size() + 1 - size;\n    auto frequencies = tcalculate_optimized(input, size);\n    std::unordered_map<unsigned, std::string> freq;\n\n    // Collect results into a vector for sorting\n    std::vector<std::pair<std::string, unsigned>> results;\n    for (const auto& i : frequencies) {\n        results.emplace_back(i.first.toString(), i.second);\n    }\n\n    // Sort the results by frequency and lexicographically\n    std::sort(results.begin(), results.end(), [](const std::pair<std::string, unsigned>& a, const std::pair<std::string, unsigned>& b) {\n        if (a.second != b.second)\n            return a.second > b.second;  // descending frequency\n        return a.first < b.first;       // ascending lexicographical order\n    });\n\n    // Print sorted results\n    for (const auto& i : results) {\n        std::cout << i.first << ' ' << (sum ? 100.0 * i.second / sum : 0.0) << '\\n';\n    }\n    std::cout << '\\n';\n}\n\nvoid write_count(const std::string& input, const std::string& str) {\n    auto frequencies = tcalculate_optimized(input, str.length());\n    std::cout << frequencies[T(str)] << '\\t' << str << '\\n';\n}\n\nint main() {\n    init();\n    std::string input;\n    char buffer[256];\n\n    while (fgets(buffer, sizeof(buffer), stdin) && memcmp(\">THREE\", buffer, 6) != 0);\n    while (fgets(buffer, sizeof(buffer), stdin) && buffer[0] != '>') {\n        if (buffer[0] != ';') {\n            input.append(buffer, strlen(buffer) - 1);\n        }\n    }\n    std::transform(input.begin(), input.end(), input.begin(), ::toupper);\n\n    std::cout << std::setprecision(3) << std::fixed;\n    write_frequencies(input, 1);\n    write_frequencies(input, 2);\n    write_count(input, \"GGT\");\n    write_count(input, \"GGTA\");\n    write_count(input, \"GGTATT\");\n    write_count(input, \"GGTATTTTAATT\");\n    write_count(input, \"GGTATTTTAATTTATAGT\");\n}",
        725.638,
        4961.36
    ],
    "5": [
        "#include <iostream>\n#include <iomanip>\n#include <cstdint>\n#include <string>\n#include <unordered_map>\n#include <thread>\n#include <vector>\n#include <sstream>\n#include <cstring>  // Required for memcmp, strlen\n#include <algorithm> // Required for std::transform\n\nunsigned char tonum[256], tochar[4];\n\nstatic void init() {\n    std::fill(std::begin(tonum), std::end(tonum), 0);  // clear the array\n    tonum['A'] = 0;\n    tonum['C'] = 1;\n    tonum['T'] = 2;\n    tonum['G'] = 3;\n    tochar[0] = 'A';\n    tochar[1] = 'C';\n    tochar[2] = 'T';\n    tochar[3] = 'G';\n}\n\nstruct T {\n    uint64_t data;\n    unsigned size;\n    T(const std::string& str = \"\") : data(0), size(str.size()) {\n        reset(str, 0, size);\n    }\n    void reset(const std::string& str, unsigned beg, unsigned end) {\n        data = 0;\n        size = end - beg;\n        for (unsigned i = beg; i < end; ++i) {\n            data <<= 2;\n            data |= tonum[(unsigned char)str[i]];\n        }\n    }\n    bool operator==(const T& other) const { return data == other.data; }\n    std::string toString() const {\n        std::string result(size, ' ');\n        uint64_t temp = data;\n        for (unsigned i = 0; i < size; ++i) {\n            result[size - 1 - i] = tochar[temp & 3];\n            temp >>= 2;\n        }\n        return result;\n    }\n    struct Hash {\n        std::size_t operator()(const T& t) const { return t.data; }\n    };\n};\n\nusing FrequencyMap = std::unordered_map<T, unsigned, T::Hash>;\n\nFrequencyMap calculate_optimized(const std::string& input, unsigned size, unsigned start, unsigned step) {\n    FrequencyMap frequencies;\n    T tmp;\n    for (unsigned i = start, i_end = input.size() + 1 - size; i < i_end; i += step) {\n        tmp.reset(input, i, i + size);  // Avoid making substrings\n        ++frequencies[tmp];\n    }\n    return frequencies;\n}\n\nFrequencyMap tcalculate_optimized(const std::string& input, unsigned size) {\n    unsigned num_threads = std::max(1u, std::min(static_cast<unsigned int>(input.size() / size), std::thread::hardware_concurrency()));\n    std::vector<std::thread> workers;\n    std::vector<FrequencyMap> thread_results(num_threads);\n\n    for (unsigned i = 0; i < num_threads; ++i) {\n        workers.emplace_back([&, i]() {\n            thread_results[i] = calculate_optimized(input, size, i, num_threads);\n        });\n    }\n\n    for (auto& worker : workers) {\n        worker.join();\n    }\n\n    FrequencyMap frequencies;\n    for (const auto& result : thread_results) {\n        for (const auto& entry : result) {\n            frequencies[entry.first] += entry.second;\n        }\n    }\n    return frequencies;\n}\n\nvoid write_frequencies(const std::string& input, unsigned size) {\n    unsigned sum = input.size() + 1 - size;\n    auto frequencies = tcalculate_optimized(input, size);\n    std::vector<std::pair<std::string, unsigned>> results;\n    results.reserve(frequencies.size());  // Reserve expected size to improve performance\n\n    for (const auto& i : frequencies) {\n        results.emplace_back(i.first.toString(), i.second);\n    }\n\n    std::sort(results.begin(), results.end(), [](const std::pair<std::string, unsigned>& a, const std::pair<std::string, unsigned>& b) {\n        if (a.second != b.second)\n            return a.second > b.second;  // descending frequency\n        return a.first < b.first;       // ascending lexicographical order\n    });\n\n    for (const auto& i : results) {\n        std::cout << i.first << ' ' << (sum ? 100.0 * i.second / sum : 0.0) << '\\n';\n    }\n    std::cout << '\\n';\n}\n\nvoid write_count(const std::string& input, const std::string& str) {\n    auto frequencies = tcalculate_optimized(input, str.length());\n    std::cout << frequencies[T(str)] << '\\t' << str << '\\n';\n}\n\nint main() {\n    init();\n    std::string input;\n    char buffer[256];\n\n    while (fgets(buffer, sizeof(buffer), stdin) && memcmp(\">THREE\", buffer, 6) != 0);\n    while (fgets(buffer, sizeof(buffer), stdin) && buffer[0] != '>') {\n        if (buffer[0] != ';') {\n            input.append(buffer, strlen(buffer) - 1);\n        }\n    }\n    std::transform(input.begin(), input.end(), input.begin(), ::toupper);\n\n    std::cout << std::setprecision(3) << std::fixed;\n    write_frequencies(input, 1);\n    write_frequencies(input, 2);\n    write_count(input, \"GGT\");\n    write_count(input, \"GGTA\");\n    write_count(input, \"GGTATT\");\n    write_count(input, \"GGTATTTTAATT\");\n    write_count(input, \"GGTATTTTAATTTATAGT\");\n}",
        773.95,
        5227.618
    ]
}

Program executed for 11.210767 minutes
Program catched 8 compilation_errors and 1 output_errors