{
    "0": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstatic int64_t fact[32];\n\nvoid initializeFact(int n)\n{\n    fact[0] = 1;\n    for (auto i = 1; i <= n; ++i)\n        fact[i] = i * fact[i - 1];\n}\n\nclass Permutation \n{\n  public:\n    Permutation(int n, int64_t start);\n    void advance();\n    int64_t countFlips() const;\n\n  private:\n     vector <int> count;\n     vector <int8_t> current;\n\n};\n\n// \n// Initialize the current value of a permutation\n// and the cycle count values used to advance .\n// \nPermutation::Permutation(int n, int64_t start)\n{\n    count.resize(n);\n    current.resize(n);\n\n    // Initialize count \n    for (auto i = n - 1; i >= 0; --i) \n    {\n        auto d = start / fact[i];\n        start = start % fact[i];\n        count[i] = d;\n    }\n\n    // Initialize current.\n    for (auto i = 0; i < n; ++i)\n        current[i] = i;\n\n    for (auto i = n - 1; i >= 0; --i) \n    {\n        auto d = count[i];\n        auto b = current.begin();\n        rotate(b, b + d, b + i + 1);\n    }\n}\n\n//\n// Advance the current permutation to the next in sequence.\n// \nvoid Permutation::advance()\n{\n    for (auto i = 1; ;++i) \n    {\n        // Tried using std::rotate here but that was slower.\n        auto first = current[0];\n        for (auto j = 0; j < i; ++j)\n            current[j] = current[j + 1];\n        current[i] = first;\n\n        ++(count[i]);\n        if (count[i] <= i)\n            break;\n        count[i] = 0;\n    }\n}\n\n//\n// Count the flips required to flip 0 to the front of the vector.\n//\n// Other than minor cosmetic changes, the following routine is\n// basically lifted from \"fannkuch-redux C gcc #5\"\n//\ninline int64_t Permutation::countFlips() const\n{\n    const auto n = current.size();\n    auto flips = 0;\n    auto first = current[0];\n    if (first > 0) \n    {\n        flips = 1;\n\n        int8_t temp[n];\n        // Make a copy of current to work on. \n        for (size_t i = 0; i < n; ++i)\n            temp[i] = current[i];\n\n\n        // Flip temp until the element at the first index is 0\n        for (; temp[first] > 0; ++flips) \n        {\n            // Record the newFirst and restore the old\n            // first at its new flipped position.\n            const int8_t newFirst = temp[first];\n            temp[first] = first;\n\n            if (first > 2) \n            {\n                int64_t low = 1, high = first - 1;\n                do \n                {\n                    swap(temp[low], temp[high]);\n                    if (!(low + 3 <= high && low < 16))\n                        break;\n                    ++low;\n                    --high;\n                } while (1);\n            }\n            // Update first to newFirst that we recorded earlier.\n            first = newFirst;\n        }\n    }\n    return flips;\n}\n\nint main(int argc, char **argv)\n{\n    const auto n = atoi(argv[1]);\n\n    // Compute some factorials for later use.\n    initializeFact(n);\n\n    // blockCount works best if it is set to a multiple of the number\n    // of CPUs so that the same number of blocks gets distributed to\n    // each cpu.  The computer used for development (Intel i7-4700MQ)\n    // had 8 \"CPU\"s (4 cores with hyperthreading) so 8, 16 and 24 \n    // all worked well.\n\n    auto blockCount = 24;\n    if (blockCount > fact[n])\n        blockCount = 1;\n    const int64_t blockLength = fact[n] / blockCount;\n\n    int64_t maxFlips = 0, checksum = 0;\n\n    // Iterate over each block.\n    #pragma omp parallel for \\\n        reduction(max:maxFlips) \\\n        reduction(+:checksum)\n\n    for (int64_t blockStart = 0;\n         blockStart < fact[n]; \n         blockStart += blockLength) \n    {\n        // first permutation for this block.\n        Permutation permutation(n, blockStart);\n\n        // Iterate over each permutation in the block.\n        auto index = blockStart;\n        while (1) \n        {\n            const auto flips = permutation.countFlips();\n\n            if (flips) \n            {\n                if (index % 2 == 0)\n                    checksum += flips;\n                else\n                    checksum -= flips;\n\n                if (flips > maxFlips)\n                    maxFlips = flips;\n            }\n\n            if (++index == blockStart + blockLength)\n                break;\n\n            // next permutation for this block.\n            permutation.advance();\n        }\n    }\n\n    // Output the results to stdout.\n    cout << checksum << endl;\n    cout << \"Pfannkuchen(\" << n << \") = \" << maxFlips << endl;\n\n    return 0;\n}",
        258.286,
        1595.226
    ],
    "1": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <omp.h> // Ensure OpenMP is included\n\nusing namespace std;\n\nstatic int64_t fact[32];\n\nvoid initializeFact(int n)\n{\n    fact[0] = 1;\n    for (auto i = 1; i <= n; ++i)\n        fact[i] = i * fact[i - 1];\n}\n\nclass Permutation \n{\n  public:\n    Permutation(int n, int64_t start);\n    inline void advance();\n    inline int64_t countFlips() const;\n\n  private:\n     vector <int> count;\n     int8_t current[32]; // Use static-sized array for better memory access\n     int size; // Add a member variable to track the size of the permutation\n\n};\n\nPermutation::Permutation(int n, int64_t start) : size(n) // Initialize size\n{\n    count.resize(n);\n\n    for (auto i = n - 1; i >= 0; --i) \n    {\n        auto d = start / fact[i];\n        start = start % fact[i];\n        count[i] = d;\n    }\n    \n    for (auto i = 0; i < n; ++i)\n        current[i] = i;\n\n    for (auto i = n - 1; i >= 0; --i) \n    {\n        auto d = count[i];\n        auto b = &current[0];\n        rotate(b, b + d, b + i + 1);\n    }\n}\n\ninline void Permutation::advance()\n{\n    for (auto i = 1; ;++i) \n    {\n        auto first = current[0];\n        for (auto j = 0; j < i; ++j)\n            current[j] = current[j + 1];\n        current[i] = first;\n\n        ++(count[i]);\n        if (count[i] <= i)\n            break;\n        count[i] = 0;\n    }\n}\n\ninline int64_t Permutation::countFlips() const\n{\n    auto flips = 0;\n    auto first = current[0];\n    if (first > 0) \n    {\n        flips = 1;\n\n        int8_t temp[32];\n        for (size_t i = 0; i < size; ++i) // Use size member variable\n            temp[i] = current[i];\n\n        for (; temp[first] > 0; ++flips) \n        {\n            const int8_t newFirst = temp[first];\n            temp[first] = first;\n\n            if (first > 2) \n            {\n                int64_t low = 1, high = first - 1;\n                do \n                {\n                    swap(temp[low], temp[high]);\n                    if (!(low + 3 <= high && low < 16))\n                        break;\n                    ++low;\n                    --high;\n                } while (1);\n            }\n            first = newFirst;\n        }\n    }\n    return flips;\n}\n\nint main(int argc, char **argv)\n{\n    const auto n = atoi(argv[1]);\n\n    initializeFact(n);\n\n    auto blockCount = 24;\n    if (blockCount > fact[n])\n        blockCount = 1;\n    const int64_t blockLength = fact[n] / blockCount;\n\n    int64_t maxFlips = 0, checksum = 0;\n\n    #pragma omp parallel for \\\n        reduction(max:maxFlips) \\\n        reduction(+:checksum)\n\n    for (int64_t blockStart = 0;\n         blockStart < fact[n]; \n         blockStart += blockLength) \n    {\n        Permutation permutation(n, blockStart);\n\n        auto index = blockStart;\n        while (1) \n        {\n            const auto flips = permutation.countFlips();\n\n            if (flips) \n            {\n                if (index % 2 == 0)\n                    checksum += flips;\n                else\n                    checksum -= flips;\n\n                if (flips > maxFlips)\n                    maxFlips = flips;\n            }\n\n            if (++index == blockStart + blockLength)\n                break;\n\n            permutation.advance();\n        }\n    }\n\n    cout << checksum << endl;\n    cout << \"Pfannkuchen(\" << n << \") = \" << maxFlips << endl;\n\n    return 0;\n}",
        247.843,
        1559.682
    ],
    "2": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n#include <cstddef> // Include for size_t\n\nusing namespace std;\n\nstatic int64_t fact[32];\n\nvoid initializeFact(int n)\n{\n    fact[0] = 1;\n    for (auto i = 1; i <= n; ++i)\n        fact[i] = i * fact[i - 1];\n}\n\nclass Permutation {\n  public:\n    Permutation(int n, int64_t start);\n    inline void advance();\n    inline int64_t countFlips() const;\n\n  private:\n    vector<int> count;\n    int8_t current[32]; // Use static-sized array for better memory access\n    int size; // Add a member variable to track the size of the permutation\n};\n\nPermutation::Permutation(int n, int64_t start) : size(n) // Initialize size\n{\n    count.resize(n);\n\n    for (auto i = n - 1; i >= 0; --i)\n    {\n        auto d = start / fact[i];\n        start = start % fact[i];\n        count[i] = d;\n    }\n    \n    for (auto i = 0; i < n; ++i)\n        current[i] = i;\n\n    for (auto i = n - 1; i >= 0; --i)\n    {\n        auto d = count[i];\n        auto b = &current[0];\n        rotate(b, b + d, b + i + 1);\n    }\n}\n\ninline void Permutation::advance()\n{\n    for (auto i = 1; ; ++i)\n    {\n        auto first = current[0];\n        for (auto j = 0; j < i; ++j)\n            current[j] = current[j + 1];\n        current[i] = first;\n\n        ++(count[i]);\n        if (count[i] <= i)\n            break;\n        count[i] = 0;\n    }\n}\n\ninline int64_t Permutation::countFlips() const\n{\n    auto flips = 0;\n    auto first = current[0];\n    if (first > 0)\n    {\n        flips = 1;\n\n        int8_t temp[32];\n        for (size_t i = 0; i < size; ++i) // Use size member variable\n            temp[i] = current[i];\n\n        for (; temp[first] > 0; ++flips)\n        {\n            const int8_t newFirst = temp[first];\n            temp[first] = first;\n\n            if (first > 2)\n            {\n                int64_t low = 1, high = first - 1;\n                do\n                {\n                    swap(temp[low], temp[high]);\n                    if (!(low + 3 <= high && low < 16))\n                        break;\n                    ++low;\n                    --high;\n                } while (1);\n            }\n            first = newFirst;\n        }\n    }\n    return flips;\n}\n\nint main(int argc, char **argv)\n{\n    const auto n = atoi(argv[1]);\n\n    initializeFact(n);\n\n    auto blockCount = 24;\n    if (blockCount > fact[n])\n        blockCount = 1;\n    const int64_t blockLength = fact[n] / blockCount;\n\n    int64_t maxFlips = 0, checksum = 0;\n\n    #pragma omp parallel for \\\n        reduction(max:maxFlips) \\\n        reduction(+:checksum)\n\n    for (int64_t blockStart = 0;\n         blockStart < fact[n]; \n         blockStart += blockLength)\n    {\n        Permutation permutation(n, blockStart);\n\n        auto index = blockStart;\n        while (1)\n        {\n            const auto flips = permutation.countFlips();\n\n            if (flips)\n            {\n                if (index % 2 == 0)\n                    checksum += flips;\n                else\n                    checksum -= flips;\n\n                if (flips > maxFlips)\n                    maxFlips = flips;\n            }\n\n            if (++index == blockStart + blockLength)\n                break;\n\n            permutation.advance();\n        }\n    }\n\n    cout << checksum << endl;\n    cout << \"Pfannkuchen(\" << n << \") = \" << maxFlips << endl;\n\n    return 0;\n}",
        245.424,
        1534.302
    ],
    "3": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n#include <cstddef>\n#include <array>\n\nusing namespace std;\n\nstatic int64_t fact[32];\n\nvoid initializeFact(int n) {\n    fact[0] = 1;\n    for (auto i = 1; i <= n; ++i)\n        fact[i] = i * fact[i - 1];\n}\n\nclass Permutation {\n  public:\n    Permutation(int n, int64_t start);\n    inline void advance();\n    inline int64_t countFlips() const;\n\n  private:\n    array<int8_t, 32> current;  // Using a fixed array instead of vector\n    array<int, 32> count; // Predefined size to avoid dynamic memory\n    int size; // Add a member variable to track the size of the permutation\n};\n\nPermutation::Permutation(int n, int64_t start) : size(n) {\n    for (int i = n - 1; i >= 0; --i) {\n        auto d = start / fact[i];\n        start = start % fact[i];\n        count[i] = d;\n    }\n    \n    for (auto i = 0; i < n; ++i)\n        current[i] = i;\n\n    for (auto i = n - 1; i >= 0; --i) {\n        auto d = count[i];\n        auto b = &current[0];\n        rotate(b, b + d, b + i + 1);\n    }\n}\n\ninline void Permutation::advance() {\n    for (auto i = 1; ; ++i) {\n        auto first = current[0];\n        for (auto j = 0; j < i; ++j)\n            current[j] = current[j + 1];\n        current[i] = first;\n\n        ++(count[i]);\n        if (count[i] <= i)\n            break;\n        count[i] = 0;\n    }\n}\n\ninline int64_t Permutation::countFlips() const {\n    auto flips = 0;\n    auto first = current[0];\n    if (first > 0) {\n        flips = 1;\n\n        array<int8_t, 32> temp;\n        for (size_t i = 0; i < size; ++i) \n            temp[i] = current[i];\n\n        for (; temp[first] > 0; ++flips) {\n            const int8_t newFirst = temp[first];\n            temp[first] = first;\n\n            if (first > 2) {\n                int64_t low = 1, high = first - 1;\n                do {\n                    swap(temp[low], temp[high]);\n                    if (!(low + 3 <= high && low < 16))\n                        break;\n                    ++low;\n                    --high;\n                } while (1);\n            }\n            first = newFirst;\n        }\n    }\n    return flips;\n}\n\nint main(int argc, char **argv) {\n    const auto n = atoi(argv[1]);\n    \n    initializeFact(n);\n\n    auto blockCount = 24;\n    if (blockCount > fact[n])\n        blockCount = 1;\n    const int64_t blockLength = fact[n] / blockCount;\n\n    int64_t maxFlips = 0, checksum = 0;\n    \n    #pragma omp parallel for \\\n        reduction(max:maxFlips) \\\n        reduction(+:checksum)\n\n    for (int64_t blockStart = 0; blockStart < fact[n]; blockStart += blockLength) {\n        Permutation permutation(n, blockStart);\n\n        auto index = blockStart;\n        while (1) {\n            const auto flips = permutation.countFlips();\n\n            if (flips) {\n                if (index % 2 == 0)\n                    checksum += flips;\n                else\n                    checksum -= flips;\n\n                if (flips > maxFlips)\n                    maxFlips = flips;\n            }\n\n            if (++index == blockStart + blockLength)\n                break;\n\n            permutation.advance();\n        }\n    }\n\n    cout << checksum << endl;\n    cout << \"Pfannkuchen(\" << n << \") = \" << maxFlips << endl;\n\n    return 0;\n}\n",
        246.122,
        1519.14
    ],
    "4": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n#include <cstddef>\n#include <array>\n\nusing namespace std;\n\nstatic int64_t fact[32];\n\nvoid initializeFact(int n) {\n    fact[0] = 1;\n    for (auto i = 1; i <= n; ++i)\n        fact[i] = i * fact[i - 1];\n}\n\nclass Permutation {\n  public:\n    Permutation(int n, int64_t start);\n    inline void advance();\n    inline int64_t countFlips() const;\n\n  private:\n    alignas(64) array<int8_t, 32> current;  // Aligning to cache line size\n    alignas(64) array<int, 32> count;\n    int size;\n};\n\nPermutation::Permutation(int n, int64_t start) : size(n) {\n    for (int i = n - 1; i >= 0; --i) {\n        auto d = start / fact[i];\n        start = start % fact[i];\n        count[i] = d;\n    }\n    \n    for (auto i = 0; i < n; ++i)\n        current[i] = i;\n\n    for (auto i = n - 1; i >= 0; --i) {\n        auto d = count[i];\n        rotate(current.begin(), current.begin() + d, current.begin() + i + 1);\n    }\n}\n\ninline void Permutation::advance() {\n    for (auto i = 1; ; ++i) {\n        auto first = current[0];\n        auto j = 0;\n        // Unroll loop by processing two elements at a time\n        for (; j < i - 1; j += 2) {\n            current[j] = current[j + 1];\n            current[j + 1] = current[j + 2];\n        }\n        if (j == i - 1) {\n            current[j] = current[j + 1];\n        }\n        current[i] = first;\n        ++(count[i]);\n        if (count[i] <= i)\n            break;\n        count[i] = 0;\n    }\n}\n\ninline int64_t Permutation::countFlips() const {\n    auto flips = 0;\n    auto first = current[0];\n    if (first > 0) {\n        flips = 1;\n\n        array<int8_t, 32> temp;\n        for (size_t i = 0; i < size; ++i) \n            temp[i] = current[i];\n\n        for (; temp[first] > 0; ++flips) {\n            const int8_t newFirst = temp[first];\n            temp[first] = first;\n\n            if (first > 2) {\n                int64_t low = 1, high = first - 1;\n                do {\n                    swap(temp[low], temp[high]);\n                    if (!(low + 3 <= high && low < 16))\n                        break;\n                    ++low;\n                    --high;\n                } while (1);\n            }\n            first = newFirst;\n        }\n    }\n    return flips;\n}\n\nint main(int argc, char **argv) {\n    const auto n = atoi(argv[1]);\n    \n    initializeFact(n);\n\n    auto blockCount = 24;\n    if (blockCount > fact[n])\n        blockCount = 1;\n    const int64_t blockLength = fact[n] / blockCount;\n\n    int64_t maxFlips = 0, checksum = 0;\n    \n    #pragma omp parallel for \\\n        reduction(max:maxFlips) \\\n        reduction(+:checksum)\n\n    for (int64_t blockStart = 0; blockStart < fact[n]; blockStart += blockLength) {\n        Permutation permutation(n, blockStart);\n\n        auto index = blockStart;\n        while (1) {\n            const auto flips = permutation.countFlips();\n\n            if (flips) {\n                if (index % 2 == 0)\n                    checksum += flips;\n                else\n                    checksum -= flips;\n\n                if (flips > maxFlips)\n                    maxFlips = flips;\n            }\n\n            if (++index == blockStart + blockLength)\n                break;\n\n            permutation.advance();\n        }\n    }\n\n    cout << checksum << endl;\n    cout << \"Pfannkuchen(\" << n << \") = \" << maxFlips << endl;\n\n    return 0;\n}",
        234.26,
        1439.86
    ],
    "5": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n#include <cstddef>\n#include <array>\n\nusing namespace std;\n\nstatic int64_t fact[32];\n\nvoid initializeFact(int n) {\n    fact[0] = 1;\n    for (auto i = 1; i <= n; ++i)\n        fact[i] = i * fact[i - 1];\n}\n\nclass Permutation {\n  public:\n    Permutation(int n, int64_t start);\n    inline void advance();\n    inline int64_t countFlips() const;\n\n  private:\n    alignas(64) array<int8_t, 32> current;  // Aligning to cache line size\n    alignas(64) array<int, 32> count;\n    int size;\n};\n\nPermutation::Permutation(int n, int64_t start) : size(n) {\n    for (int i = n - 1; i >= 0; --i) {\n        auto d = start / fact[i];\n        start = start % fact[i];\n        count[i] = d;\n    }\n    \n    for (auto i = 0; i < n; ++i)\n        current[i] = i;\n\n    for (auto i = n - 1; i >= 0; --i) {\n        auto d = count[i];\n        rotate(current.begin(), current.begin() + d, current.begin() + i + 1);\n    }\n}\n\ninline void Permutation::advance() {\n    for (auto i = 1; ; ++i) {\n        auto first = current[0];\n        auto j = 0;\n        // Unroll loop by processing two elements at a time\n        for (; j < i - 1; j += 2) {\n            current[j] = current[j + 1];\n            current[j + 1] = current[j + 2];\n        }\n        if (j == i - 1) {\n            current[j] = current[j + 1];\n        }\n        current[i] = first;\n        ++(count[i]);\n        if (count[i] <= i)\n            break;\n        count[i] = 0;\n    }\n}\n\ninline int64_t Permutation::countFlips() const {\n    auto flips = 0;\n    auto first = current[0];\n    if (first > 0) {\n        flips = 1;\n\n        array<int8_t, 32> temp;\n        for (size_t i = 0; i < size; ++i) \n            temp[i] = current[i];\n\n        for (; temp[first] > 0; ++flips) {\n            const int8_t newFirst = temp[first];\n            temp[first] = first;\n\n            if (first > 2) {\n                int64_t low = 1, high = first - 1;\n                do {\n                    swap(temp[low], temp[high]);\n                    if (!(low + 3 <= high && low < 16))\n                        break;\n                    ++low;\n                    --high;\n                } while (1);\n            }\n            first = newFirst;\n        }\n    }\n    return flips;\n}\n\nint main(int argc, char **argv) {\n    const auto n = atoi(argv[1]);\n    \n    initializeFact(n);\n\n    auto blockCount = 24;\n    if (blockCount > fact[n])\n        blockCount = 1;\n    const int64_t blockLength = fact[n] / blockCount;\n\n    int64_t maxFlips = 0, checksum = 0;\n    \n    #pragma omp parallel for \\\n        reduction(max:maxFlips) \\\n        reduction(+:checksum)\n\n    for (int64_t blockStart = 0; blockStart < fact[n]; blockStart += blockLength) {\n        Permutation permutation(n, blockStart);\n\n        auto index = blockStart;\n        while (1) {\n            const auto flips = permutation.countFlips();\n\n            if (flips) {\n                if (index % 2 == 0)\n                    checksum += flips;\n                else\n                    checksum -= flips;\n\n                if (flips > maxFlips)\n                    maxFlips = flips;\n            }\n\n            if (++index == blockStart + blockLength)\n                break;\n\n            permutation.advance();\n        }\n    }\n\n    cout << checksum << endl;\n    cout << \"Pfannkuchen(\" << n << \") = \" << maxFlips << endl;\n\n    return 0;\n}",
        234.2,
        1433.95
    ]
}