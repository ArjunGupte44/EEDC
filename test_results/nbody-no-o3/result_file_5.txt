{
    "0": [
        "#include <algorithm>\n#include <stdio.h>\n#include <cmath>\n#include <stdlib.h>\n#include <immintrin.h>\n#include <array>\n\nconstexpr double PI(3.141592653589793);\nconstexpr double SOLAR_MASS ( 4 * PI * PI );\nconstexpr double DAYS_PER_YEAR(365.24);\n\nstruct body {\n  double x[3], fill, v[3], mass;\n  constexpr body(double x0, double x1, double x2, double v0, double v1, double v2,  double Mass):\n    x{x0,x1,x2}, fill(0), v{v0,v1,v2}, mass(Mass) {}\n};\n\nclass N_Body_System\n{\n  static std::array<body,5> bodies;\n\n  void offset_momentum()\n  {\n    unsigned int k;\n    for(auto &body: bodies)\n      for(k = 0; k < 3; ++k)\n        bodies[0].v[k] -= body.v[k] * body.mass / SOLAR_MASS;\n  }\n\npublic:\n  N_Body_System()\n  {\n    offset_momentum();\n  }\n  void advance(double dt)\n  {\n    constexpr unsigned int N = ((bodies.size() - 1) * bodies.size()) / 2;\n\n    static double r[N][4];\n    static double mag[N];\n\n    unsigned int i, m;\n    __m128d dx[3], dsquared, distance, dmag;\n\n    i=0;\n    for(auto bi(bodies.begin()); bi!=bodies.end(); ++bi)\n      {\n        auto bj(bi);\n        for(++bj; bj!=bodies.end(); ++bj, ++i)\n          for (m=0; m<3; ++m)\n            r[i][m] = bi->x[m] - bj->x[m];\n      }\n\n    for (i=0; i<N; i+=2)\n      {\n        for (m=0; m<3; ++m)\n          {\n            dx[m] = _mm_loadl_pd(dx[m], &r[i][m]);\n            dx[m] = _mm_loadh_pd(dx[m], &r[i+1][m]);\n          }\n\n        dsquared = dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2];\n        distance = _mm_cvtps_pd(_mm_rsqrt_ps(_mm_cvtpd_ps(dsquared)));\n\n        for (m=0; m<2; ++m)\n          distance = distance * _mm_set1_pd(1.5)\n            - ((_mm_set1_pd(0.5) * dsquared) * distance)\n            * (distance * distance);\n\n        dmag = _mm_set1_pd(dt) / (dsquared) * distance;\n        _mm_store_pd(&mag[i], dmag);\n      }\n\n    i=0;\n    for(auto bi(bodies.begin()); bi!=bodies.end(); ++bi)\n      {\n        auto bj(bi);\n        for(++bj; bj!=bodies.end(); ++bj, ++i)\n          for(m=0; m<3; ++m)\n            {\n              const double x = r[i][m] * mag[i];\n              bi->v[m] -= x * bj->mass;\n              bj->v[m] += x * bi->mass;\n            }\n      }\n\n    for(auto &body: bodies)\n      for(m=0; m<3; ++m)\n        body.x[m] += dt * body.v[m];\n  }\n\n  double energy()\n  {\n    double e(0.0);\n    for(auto bi(bodies.cbegin()); bi!=bodies.cend(); ++bi)\n      {\n        e += bi->mass * ( bi->v[0] * bi->v[0]\n                          + bi->v[1] * bi->v[1]\n                          + bi->v[2] * bi->v[2] ) / 2.;\n\n        auto bj(bi);\n        for(++bj; bj!=bodies.end(); ++bj)\n          {\n            double distance = 0;\n            for(auto k=0; k<3; ++k)\n            {\n              const double dx = bi->x[k] - bj->x[k];\n              distance += dx * dx;\n            }\n\n            e -= (bi->mass * bj->mass) / std::sqrt(distance);\n          }\n      }\n    return e;\n  }\n};\n\n\nstd::array<body,5> N_Body_System::bodies{{\n    /* sun */\n    body(0., 0., 0. ,\n         0., 0., 0. ,\n         SOLAR_MASS),\n    /* jupiter */\n    body(4.84143144246472090e+00,\n         -1.16032004402742839e+00,\n         -1.03622044471123109e-01 ,\n         1.66007664274403694e-03 * DAYS_PER_YEAR,\n         7.69901118419740425e-03 * DAYS_PER_YEAR,\n         -6.90460016972063023e-05 * DAYS_PER_YEAR ,\n         9.54791938424326609e-04 * SOLAR_MASS\n         ),\n    /* saturn */\n    body(8.34336671824457987e+00,\n         4.12479856412430479e+00,\n         -4.03523417114321381e-01 ,\n         -2.76742510726862411e-03 * DAYS_PER_YEAR,\n         4.99852801234917238e-03 * DAYS_PER_YEAR,\n         2.30417297573763929e-05 * DAYS_PER_YEAR ,\n         2.85885980666130812e-04 * SOLAR_MASS\n         ),\n    /* uranus */\n    body(1.28943695621391310e+01,\n         -1.51111514016986312e+01,\n         -2.23307578892655734e-01 ,\n         2.96460137564761618e-03 * DAYS_PER_YEAR,\n         2.37847173959480950e-03 * DAYS_PER_YEAR,\n         -2.96589568540237556e-05 * DAYS_PER_YEAR ,\n         4.36624404335156298e-05 * SOLAR_MASS\n         ),\n    /* neptune */\n    body(1.53796971148509165e+01,\n         -2.59193146099879641e+01,\n         1.79258772950371181e-01 ,\n         2.68067772490389322e-03 * DAYS_PER_YEAR,\n         1.62824170038242295e-03 * DAYS_PER_YEAR,\n         -9.51592254519715870e-05 * DAYS_PER_YEAR ,\n         5.15138902046611451e-05 * SOLAR_MASS\n         )\n  }};\n\nint main(int , char** argv)\n{\n  int i, n = atoi(argv[1]);\n  N_Body_System system;\n\n  printf(\"%.9f\\n\", system.energy());\n  for (i = 0; i < n; ++i)\n    system.advance(0.01);\n  printf(\"%.9f\\n\", system.energy());\n\n  return 0;\n}",
        1148.345,
        20765.22
    ],
    "1": [
        "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <cmath>\n#include <stdlib.h>\n#include <immintrin.h>\n#include <array>\n\nconstexpr double PI(3.141592653589793);\nconstexpr double SOLAR_MASS ( 4 * PI * PI );\nconstexpr double DAYS_PER_YEAR(365.24);\n\n// Class representing a celestial body\nstruct body {\n  double x[3], fill, v[3], mass;\n  constexpr body(double x0, double x1, double x2, double v0, double v1, double v2,  double Mass):\n    x{x0,x1,x2}, fill(0), v{v0,v1,v2}, mass(Mass) {}\n};\n\n// Class representing the N-body system\nclass N_Body_System {\n  static std::array<body,5> bodies;  // Static array of celestial bodies\n\n  // Function to offset momentum\n  void offset_momentum() {\n    unsigned int k;\n    for(auto &body: bodies) {\n      for(k = 0; k < 3; ++k) {\n        bodies[0].v[k] -= body.v[k] * body.mass / SOLAR_MASS;\n      }\n    }\n  }\n\npublic:\n  N_Body_System() {\n    offset_momentum();  // Offset momentum at initialization\n  }\n\n  // Function to advance the simulation by time dt\n  void advance(double dt) {\n    constexpr unsigned int N = ((bodies.size() - 1) * bodies.size()) / 2;\n    static double r[N][4];\n    static double mag[N];\n\n    unsigned int i, m;\n    __m128d dx[3], dsquared, distance, dmag;\n\n    i = 0;\n    for(auto bi = bodies.begin(); bi != bodies.end(); ++bi) {\n      auto bj = bi;\n      for(++bj; bj != bodies.end(); ++bj, ++i) {\n        for(m = 0; m < 3; ++m) {\n          r[i][m] = bi->x[m] - bj->x[m];\n        }\n      }\n    }\n\n    // Process pairs in chunks\n    for(i = 0; i < N; i += 2) {\n      for(m = 0; m < 3; ++m) {\n        dx[m] = _mm_loadl_pd(dx[m], &r[i][m]);\n        dx[m] = _mm_loadh_pd(dx[m], &r[i+1][m]);\n      }\n      \n      dsquared = dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2];\n      distance = _mm_cvtps_pd(_mm_rsqrt_ps(_mm_cvtpd_ps(dsquared)));\n\n      for(m = 0; m < 2; ++m) {\n        distance = distance * _mm_set1_pd(1.5) - ((_mm_set1_pd(0.5) * dsquared) * distance) * (distance * distance);\n      }\n      \n      dmag = _mm_set1_pd(dt) / (dsquared) * distance;\n      _mm_store_pd(&mag[i], dmag);\n    }\n    \n    i = 0;\n    for(auto bi = bodies.begin(); bi != bodies.end(); ++bi) {\n      auto bj = bi;\n      for(++bj; bj != bodies.end(); ++bj, ++i) {\n        for(m = 0; m < 3; ++m) {\n          const double x = r[i][m] * mag[i];\n          bi->v[m] -= x * bj->mass;\n          bj->v[m] += x * bi->mass;\n        }\n      }\n    }\n\n    for(auto &body: bodies) {\n      for(m = 0; m < 3; ++m) {\n        body.x[m] += dt * body.v[m];\n      }\n    }\n  }\n\n  // Function to calculate the energy of the system\n  double energy() {\n    double e(0.0);\n    for(auto bi = bodies.cbegin(); bi != bodies.cend(); ++bi) {\n      e += bi->mass * ( bi->v[0] * bi->v[0] + bi->v[1] * bi->v[1] + bi->v[2] * bi->v[2] ) / 2.0;\n\n      auto bj = bi;\n      for(++bj; bj != bodies.end(); ++bj) {\n        double distSquared(0.0), dx(0.0);\n        for(int k = 0; k < 3; ++k) {\n          dx = bi->x[k] - bj->x[k];\n          distSquared += dx * dx;\n        }\n        e -= (bi->mass * bj->mass) / std::sqrt(distSquared);\n      }\n    }\n    return e;\n  }\n};\n\n// Static initialization of bodies in the N-body system\nstd::array<body,5> N_Body_System::bodies{{\n  /* sun */\n  body(0., 0., 0. , 0., 0., 0. , SOLAR_MASS),\n  /* jupiter */\n  body(4.84143144246472090e+00, -1.16032004402742839e+00, -1.03622044471123109e-01, 1.66007664274403694e-03 * DAYS_PER_YEAR, 7.69901118419740425e-03 * DAYS_PER_YEAR, -6.90460016972063023e-05 * DAYS_PER_YEAR, 9.54791938424326609e-04 * SOLAR_MASS),\n  /* saturn */\n  body(8.34336671824457987e+00, 4.12479856412430479e+00, -4.03523417114321381e-01, -2.76742510726862411e-03 * DAYS_PER_YEAR, 4.99852801234917238e-03 * DAYS_PER_YEAR, 2.30417297573763929e-05 * DAYS_PER_YEAR, 2.85885980666130812e-04 * SOLAR_MASS),\n  /* uranus */\n  body(1.28943695621391310e+01, -1.51111514016986312e+01, -2.23307578892655734e-01, 2.96460137564761618e-03 * DAYS_PER_YEAR, 2.37847173959480950e-03 * DAYS_PER_YEAR, -2.96589568540237556e-05 * DAYS_PER_YEAR, 4.36624404335156298e-05 * SOLAR_MASS),\n  /* neptune */\n  body(1.53796971148509165e+01, -2.59193146099879641e+01, 1.79258772950371181e-01, 2.68067772490389322e-03 * DAYS_PER_YEAR, 1.62824170038242295e-03 * DAYS_PER_YEAR, -9.51592254519715870e-05 * DAYS_PER_YEAR, 5.15138902046611451e-05 * SOLAR_MASS)\n}};\n\n// Main function to execute the simulation\nint main(int argc, char** argv) {\n  if (argc < 2) {\n    std::cerr << \"Usage: \" << argv[0] << \" <number of iterations>\" << std::endl;\n    return 1;\n  }\n\n  int i, n = atoi(argv[1]);\n  N_Body_System system;\n\n  // Output initial system energy\n  printf(\"%.9f\\n\", system.energy());\n\n  // Advance system and output energy after simulations\n  for (i = 0; i < n; ++i) {\n    system.advance(0.01);\n  }\n\n  // Output final system energy\n  printf(\"%.9f\\n\", system.energy());\n\n  return 0;\n}",
        1154.965,
        20955.2
    ],
    "2": [
        "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <cmath>\n#include <stdlib.h>\n#include <immintrin.h>\n#include <array>\n\nconstexpr double PI(3.141592653589793);\nconstexpr double SOLAR_MASS ( 4 * PI * PI );\nconstexpr double DAYS_PER_YEAR(365.24);\n\n// Class representing a celestial body\nstruct body {\n  double x[3], v[3], mass;\n  constexpr body(double x0, double x1, double x2, double v0, double v1, double v2,  double Mass):\n    x{x0,x1,x2}, v{v0,v1,v2}, mass(Mass) {}\n};\n\n// Class representing the N-body system\nclass N_Body_System {\n  static std::array<body,5> bodies;  // Static array of celestial bodies\n\n  // Function to offset momentum\n  void offset_momentum() {\n    unsigned int k;\n    for(auto &body: bodies) {\n      for(k = 0; k < 3; ++k) {\n        bodies[0].v[k] -= body.v[k] * body.mass / SOLAR_MASS;\n      }\n    }\n  }\n\npublic:\n  N_Body_System() {\n    offset_momentum();  // Offset momentum at initialization\n  }\n\n  // Function to advance the simulation by time dt\n  void advance(double dt) {\n    constexpr unsigned int N = ((bodies.size() - 1) * bodies.size()) / 2;\n    static double r[N][3];\n    static double mag[N];\n\n    unsigned int i, m;\n    i = 0;\n    for(auto bi = bodies.begin(); bi != bodies.end(); ++bi) {\n      auto bj = bi;\n      for(++bj; bj != bodies.end(); ++bj, ++i) {\n        for(m = 0; m < 3; ++m) {\n          r[i][m] = bi->x[m] - bj->x[m];\n        }\n        double distSquared = r[i][0] * r[i][0] + r[i][1] * r[i][1] + r[i][2] * r[i][2];\n        double distance = std::sqrt(distSquared);\n        mag[i] = dt / (distSquared * distance);\n      }\n    }\n    \n    i = 0;\n    for(auto bi = bodies.begin(); bi != bodies.end(); ++bi) {\n      auto bj = bi;\n      for(++bj; bj != bodies.end(); ++bj, ++i) {\n        for(m = 0; m < 3; ++m) {\n          const double force = r[i][m] * mag[i];\n          bi->v[m] -= force * bj->mass;\n          bj->v[m] += force * bi->mass;\n        }\n      }\n    }\n\n    for(auto &body: bodies) {\n      for(m = 0; m < 3; ++m) {\n        body.x[m] += dt * body.v[m];\n      }\n    }\n  }\n\n  // Function to calculate the energy of the system\n  double energy() {\n    double e(0.0);\n    for(auto bi = bodies.cbegin(); bi != bodies.cend(); ++bi) {\n      e += bi->mass * ( bi->v[0] * bi->v[0] + bi->v[1] * bi->v[1] + bi->v[2] * bi->v[2] ) / 2.0;\n\n      auto bj = bi;\n      for(++bj; bj != bodies.end(); ++bj) {\n        double distSquared(0.0), dx(0.0);\n        for(int k = 0; k < 3; ++k) {\n          dx = bi->x[k] - bj->x[k];\n          distSquared += dx * dx;\n        }\n        e -= (bi->mass * bj->mass) / std::sqrt(distSquared);\n      }\n    }\n    return e;\n  }\n};\n\n// Static initialization of bodies in the N-body system\nstd::array<body,5> N_Body_System::bodies{{\n  /* sun */\n  body(0., 0., 0. , 0., 0., 0. , SOLAR_MASS),\n  /* jupiter */\n  body(4.84143144246472090e+00, -1.16032004402742839e+00, -1.03622044471123109e-01, 1.66007664274403694e-03 * DAYS_PER_YEAR, 7.69901118419740425e-03 * DAYS_PER_YEAR, -6.90460016972063023e-05 * DAYS_PER_YEAR, 9.54791938424326609e-04 * SOLAR_MASS),\n  /* saturn */\n  body(8.34336671824457987e+00, 4.12479856412430479e+00, -4.03523417114321381e-01, -2.76742510726862411e-03 * DAYS_PER_YEAR, 4.99852801234917238e-03 * DAYS_PER_YEAR, 2.30417297573763929e-05 * DAYS_PER_YEAR, 2.85885980666130812e-04 * SOLAR_MASS),\n  /* uranus */\n  body(1.28943695621391310e+01, -1.51111514016986312e+01, -2.23307578892655734e-01, 2.96460137564761618e-03 * DAYS_PER_YEAR, 2.37847173959480950e-03 * DAYS_PER_YEAR, -2.96589568540237556e-05 * DAYS_PER_YEAR, 4.36624404335156298e-05 * SOLAR_MASS),\n  /* neptune */\n  body(1.53796971148509165e+01, -2.59193146099879641e+01, 1.79258772950371181e-01, 2.68067772490389322e-03 * DAYS_PER_YEAR, 1.62824170038242295e-03 * DAYS_PER_YEAR, -9.51592254519715870e-05 * DAYS_PER_YEAR, 5.15138902046611451e-05 * SOLAR_MASS)\n}};\n\n// Main function to execute the simulation\nint main(int argc, char** argv) {\n  if (argc < 2) {\n    std::cerr << \"Usage: \" << argv[0] << \" <number of iterations>\" << std::endl;\n    return 1;\n  }\n\n  int i, n = atoi(argv[1]);\n  N_Body_System system;\n\n  // Output initial system energy\n  printf(\"%.9f\\n\", system.energy());\n\n  // Advance system and output energy after simulations\n  for (i = 0; i < n; ++i) {\n    system.advance(0.01);\n  }\n\n  // Output final system energy\n  printf(\"%.9f\\n\", system.energy());\n\n  return 0;\n}",
        1041.96,
        18900.02
    ],
    "3": [
        "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <iomanip> // For setting precision\n#include <cstddef> // For size_t\n#include <array> // For std::array\n\nconstexpr double PI(3.141592653589793);\nconstexpr double SOLAR_MASS ( 4 * PI * PI );\nconstexpr double DAYS_PER_YEAR(365.24);\n\nstruct body {\n    double x[3], v[3], mass;\n    constexpr body(double x0, double x1, double x2, double v0, double v1, double v2, double Mass):\n    x{x0,x1,x2}, v{v0,v1,v2}, mass(Mass) {}\n};\n\nclass N_Body_System {\n    static std::array<body,5> bodies;\n\n    void offset_momentum() {\n        for(auto &body: bodies) {\n            for(size_t k = 0; k < 3; ++k) {\n                bodies[0].v[k] -= body.v[k] * body.mass / SOLAR_MASS;\n            }\n        }\n    }\n\npublic:\n    N_Body_System() {\n        offset_momentum();\n    }\n\n    void advance(double dt) {\n        constexpr size_t N = ((bodies.size() - 1) * bodies.size()) / 2;\n        static double r[N][3];\n        static double mag[N];\n\n        size_t idx = 0;\n        for(auto bi = bodies.begin(); bi != bodies.end(); ++bi) {\n            for(auto bj = bi + 1; bj != bodies.end(); ++bj, ++idx) {\n                double distSquared = 0.0;\n                for(size_t m = 0; m < 3; ++m) {\n                    r[idx][m] = bi->x[m] - bj->x[m];\n                    distSquared += r[idx][m] * r[idx][m];\n                }\n                double distance = 1.0 / std::sqrt(distSquared);\n                mag[idx] = dt * distance * distance * distance;\n            }\n        }\n\n        idx = 0;\n        for(auto bi = bodies.begin(); bi != bodies.end(); ++bi) {\n            for(auto bj = bi + 1; bj != bodies.end(); ++bj, ++idx) {\n                double invMassProduct = mag[idx];\n                for(size_t m = 0; m < 3; ++m) {\n                    const double force = r[idx][m] * invMassProduct;\n                    bi->v[m] -= force * bj->mass;\n                    bj->v[m] += force * bi->mass;\n                }\n            }\n        }\n\n        for(auto &body : bodies) {\n            for(size_t m = 0; m < 3; ++m) {\n                body.x[m] += dt * body.v[m];\n            }\n        }\n    }\n\n    double energy() const {\n        double e(0.0);\n        for(auto bi = bodies.cbegin(); bi != bodies.cend(); ++bi) {\n            e += bi->mass * (bi->v[0] * bi->v[0] + bi->v[1] * bi->v[1] + bi->v[2] * bi->v[2]) / 2.0;\n\n            for(auto bj = bi + 1; bj != bodies.cend(); ++bj) {\n                double distSquared(0.0);\n                for(size_t k = 0; k < 3; ++k) {\n                    auto dx = bi->x[k] - bj->x[k];\n                    distSquared += dx * dx;\n                }\n                e -= (bi->mass * bj->mass) / std::sqrt(distSquared);\n            }\n        }\n        return e;\n    }\n};\n\nstd::array<body,5> N_Body_System::bodies{{\n    body(0., 0., 0. , 0., 0., 0., SOLAR_MASS),\n    body(4.84143144246472090e+00, -1.16032004402742839e+00, -1.03622044471123109e-01, 1.66007664274403694e-03 * DAYS_PER_YEAR, 7.69901118419740425e-03 * DAYS_PER_YEAR, -6.90460016972063023e-05 * DAYS_PER_YEAR, 9.54791938424326609e-04 * SOLAR_MASS),\n    body(8.34336671824457987e+00, 4.12479856412430479e+00, -4.03523417114321381e-01, -2.76742510726862411e-03 * DAYS_PER_YEAR, 4.99852801234917238e-03 * DAYS_PER_YEAR, 2.30417297573763929e-05 * DAYS_PER_YEAR, 2.85885980666130812e-04 * SOLAR_MASS),\n    body(1.28943695621391310e+01, -1.51111514016986312e+01, -2.23307578892655734e-01, 2.96460137564761618e-03 * DAYS_PER_YEAR, 2.37847173959480950e-03 * DAYS_PER_YEAR, -2.96589568540237556e-05 * DAYS_PER_YEAR, 4.36624404335156298e-05 * SOLAR_MASS),\n    body(1.53796971148509165e+01, -2.59193146099879641e+01, 1.79258772950371181e-01, 2.68067772490389322e-03 * DAYS_PER_YEAR, 1.62824170038242295e-03 * DAYS_PER_YEAR, -9.51592254519715870e-05 * DAYS_PER_YEAR, 5.15138902046611451e-05 * SOLAR_MASS)\n}};\n\nint main(int argc, char** argv) {\n    std::cout << std::fixed << std::setprecision(9);  // Ensure high precision output\n    if (argc < 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <number of iterations>\" << std::endl;\n        return 1;\n    }\n\n    int n = std::atoi(argv[1]);\n    N_Body_System system;\n\n    std::cout << system.energy() << std::endl;\n\n    for (int i = 0; i < n; ++i) {\n        system.advance(0.01);\n    }\n\n    std::cout << system.energy() << std::endl;\n\n    return 0;\n}\n\n",
        1105.194,
        20259.64
    ],
    "4": [
        "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <iomanip> // For setting precision\n#include <array> // For std::array\n\nconstexpr double PI(3.141592653589793);\nconstexpr double SOLAR_MASS ( 4 * PI * PI );\nconstexpr double DAYS_PER_YEAR(365.24);\n\nstruct body {\n    double x[3], v[3], mass;\n    constexpr body(double x0, double x1, double x2, double v0, double v1, double v2, double Mass):\n    x{x0,x1,x2}, v{v0,v1,v2}, mass(Mass) {}\n};\n\nclass N_Body_System {\n    static std::array<body,5> bodies;\n\n    void offset_momentum() {\n        for(auto &body: bodies) {\n            for(size_t k = 0; k < 3; ++k) {\n                bodies[0].v[k] -= body.v[k] * body.mass / SOLAR_MASS;\n            }\n        }\n    }\n\npublic:\n    N_Body_System() {\n        offset_momentum();\n    }\n\n    void advance(double dt) {\n        constexpr size_t N = ((bodies.size() - 1) * bodies.size()) / 2;\n        static std::array<std::array<double, 3>, N> r;\n        static std::array<double, N> mag;\n\n        size_t idx = 0;\n        for(auto bi = bodies.begin(); bi != bodies.end(); ++bi) {\n            for(auto bj = bi + 1; bj != bodies.end(); ++bj, ++idx) {\n                double distSquared = 0.0;\n                for(size_t m = 0; m < 3; ++m) {\n                    r[idx][m] = bi->x[m] - bj->x[m];\n                    distSquared += r[idx][m] * r[idx][m];\n                }\n                double distance = std::sqrt(distSquared);\n                mag[idx] = dt / (distSquared * distance);\n            }\n        }\n\n        idx = 0;\n        for(auto bi = bodies.begin(); bi != bodies.end(); ++bi) {\n            for(auto bj = bi + 1; bj != bodies.end(); ++bj, ++idx) {\n                double invMassProduct = mag[idx];\n                for(size_t m = 0; m < 3; ++m) {\n                    const double force = r[idx][m] * invMassProduct;\n                    bi->v[m] -= force * bj->mass;\n                    bj->v[m] += force * bi->mass;\n                }\n            }\n        }\n\n        for(auto &body : bodies) {\n            for(size_t m = 0; m < 3; ++m) {\n                body.x[m] += dt * body.v[m];\n            }\n        }\n    }\n\n    double energy() const {\n        double e(0.0);\n        for(auto bi = bodies.cbegin(); bi != bodies.cend(); ++bi) {\n            e += bi->mass * (bi->v[0] * bi->v[0] + bi->v[1] * bi->v[1] + bi->v[2] * bi->v[2]) / 2.0;\n\n            for(auto bj = bi + 1; bj != bodies.cend(); ++bj) {\n                double distSquared(0.0);\n                for(size_t k = 0; k < 3; ++k) {\n                    auto dx = bi->x[k] - bj->x[k];\n                    distSquared += dx * dx;\n                }\n                e -= (bi->mass * bj->mass) / std::sqrt(distSquared);\n            }\n        }\n        return e;\n    }\n};\n\nstd::array<body,5> N_Body_System::bodies{{\n    body(0., 0., 0. , 0., 0., 0., SOLAR_MASS),\n    body(4.84143144246472090e+00, -1.16032004402742839e+00, -1.03622044471123109e-01, 1.66007664274403694e-03 * DAYS_PER_YEAR, 7.69901118419740425e-03 * DAYS_PER_YEAR, -6.90460016972063023e-05 * DAYS_PER_YEAR, 9.54791938424326609e-04 * SOLAR_MASS),\n    body(8.34336671824457987e+00, 4.12479856412430479e+00, -4.03523417114321381e-01, -2.76742510726862411e-03 * DAYS_PER_YEAR, 4.99852801234917238e-03 * DAYS_PER_YEAR, 2.30417297573763929e-05 * DAYS_PER_YEAR, 2.85885980666130812e-04 * SOLAR_MASS),\n    body(1.28943695621391310e+01, -1.51111514016986312e+01, -2.23307578892655734e-01, 2.96460137564761618e-03 * DAYS_PER_YEAR, 2.37847173959480950e-03 * DAYS_PER_YEAR, -2.96589568540237556e-05 * DAYS_PER_YEAR, 4.36624404335156298e-05 * SOLAR_MASS),\n    body(1.53796971148509165e+01, -2.59193146099879641e+01, 1.79258772950371181e-01, 2.68067772490389322e-03 * DAYS_PER_YEAR, 1.62824170038242295e-03 * DAYS_PER_YEAR, -9.51592254519715870e-05 * DAYS_PER_YEAR, 5.15138902046611451e-05 * SOLAR_MASS)\n}};\n\nint main(int argc, char** argv) {\n    std::cout << std::fixed << std::setprecision(9);  // Ensure high precision output\n    if (argc < 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <number of iterations>\" << std::endl;\n        return 1;\n    }\n\n    int n = std::atoi(argv[1]);\n    N_Body_System system;\n\n    std::cout << system.energy() << std::endl;\n\n    for (int i = 0; i < n; ++i) {\n        system.advance(0.01);\n    }\n\n    std::cout << system.energy() << std::endl;\n\n    return 0;\n}",
        2726.893,
        49414.54
    ],
    "5": [
        "#include <iostream>\n#include <cmath>\n#include <array>\n#include <iomanip>\n\nconstexpr double PI = 3.141592653589793;\nconstexpr double SOLAR_MASS = 4 * PI * PI;\nconstexpr double DAYS_PER_YEAR = 365.24;\n\nstruct Body {\n    double x[3], v[3], mass;\n    constexpr Body(double x0, double x1, double x2, double v0, double v1, double v2, double Mass)\n        : x{x0, x1, x2}, v{v0, v1, v2}, mass(Mass) {}\n};\n\nclass NBodySystem {\npublic:\n    std::array<Body, 5> bodies;\n\n    NBodySystem() \n        : bodies({Body(0, 0, 0, 0, 0, 0, SOLAR_MASS),\n                 Body(4.84143144246472090e+00, -1.16032004402742839e+00, -1.03622044471123109e-01,\n                      1.66007664274403694e-03 * DAYS_PER_YEAR, 7.69901118419740425e-03 * DAYS_PER_YEAR,\n                      -6.90460016972063023e-05 * DAYS_PER_YEAR, 9.54791938424326609e-04 * SOLAR_MASS),\n                 Body(8.34336671824457987e+00, 4.12479856412430479e+00, -4.03523417114321381e-01,\n                      -2.76742510726862411e-03 * DAYS_PER_YEAR, 4.99852801234917238e-03 * DAYS_PER_YEAR,\n                      2.30417297573763929e-05 * DAYS_PER_YEAR, 2.85885980666130812e-04 * SOLAR_MASS),\n                 Body(1.28943695621391310e+01, -1.51111514016986312e+01, -2.23307578892655734e-01,\n                      2.96460137564761618e-03 * DAYS_PER_YEAR, 2.37847173959480950e-03 * DAYS_PER_YEAR,\n                      -2.96589568540237556e-05 * DAYS_PER_YEAR, 4.36624404335156298e-05 * SOLAR_MASS),\n                 Body(1.53796971148509165e+01, -2.59193146099879641e+01, 1.79258772950371181e-01,\n                      2.68067772490389322e-03 * DAYS_PER_YEAR, 1.62824170038242295e-03 * DAYS_PER_YEAR,\n                      -9.51592254519715870e-05 * DAYS_PER_YEAR, 5.15138902046611451e-05 * SOLAR_MASS)}) {\n        offsetMomentum();\n    }\n\n    void offsetMomentum() {\n        for (size_t k = 0; k < 3; ++k) {\n            double p = 0.0;\n            for (const auto &body : bodies) {\n                p += body.v[k] * body.mass;\n            }\n            bodies[0].v[k] = -p / SOLAR_MASS;\n        }\n    }\n\n    void advance(double dt) {\n        constexpr size_t N = ((5 - 1) * 5) / 2;\n        std::array<std::array<double, 3>, N> r;\n        std::array<double, N> mag;\n\n        size_t idx = 0;\n        for (auto i = bodies.begin(); i != bodies.end(); ++i) {\n            for (auto j = i + 1; j != bodies.end(); ++j, ++idx) {\n                double distSquared = 0.0;\n                for (size_t m = 0; m < 3; ++m) {\n                    r[idx][m] = i->x[m] - j->x[m];\n                    distSquared += r[idx][m] * r[idx][m];\n                }\n                double distance = std::sqrt(distSquared);\n                mag[idx] = dt / (distSquared * distance);\n            }\n        }\n\n        idx = 0;\n        for (auto i = bodies.begin(); i != bodies.end(); ++i) {\n            for (auto j = i + 1; j != bodies.end(); ++j, ++idx) {\n                for (size_t m = 0; m < 3; ++m) {\n                    double force = r[idx][m] * mag[idx];\n                    i->v[m] -= force * j->mass;\n                    j->v[m] += force * i->mass;\n                }\n            }\n        }\n\n        for (auto &i : bodies) {\n            for (size_t m = 0; m < 3; ++m) {\n                i.x[m] += dt * i.v[m];\n            }\n        }\n    }\n\n    double energy() const {\n        double e = 0.0;\n        for (auto i = bodies.cbegin(); i != bodies.cend(); ++i) {\n            e += i->mass * (i->v[0] * i->v[0] + i->v[1] * i->v[1] + i->v[2] * i->v[2]) / 2.0;\n\n            for (auto j = i + 1; j != bodies.cend(); ++j) {\n                double distSquared = 0.0;\n                for (size_t k = 0; k < 3; ++k) {\n                    auto dx = i->x[k] - j->x[k];\n                    distSquared += dx * dx;\n                }\n                e -= (i->mass * j->mass) / std::sqrt(distSquared);\n            }\n        }\n        return e;\n    }\n};\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <number of iterations>\" << std::endl;\n        return 1;\n    }\n\n    int n = std::atoi(argv[1]);\n    NBodySystem system;\n\n    std::cout << std::fixed << std::setprecision(9) << system.energy() << std::endl;\n\n    for (int i = 0; i < n; ++i) {\n        system.advance(0.01);\n    }\n\n    std::cout << system.energy() << std::endl;\n\n    return 0;\n}",
        2952.742,
        53235.1
    ]
}