{
    "0": [
        "#include <algorithm>\n#include <stdio.h>\n#include <cmath>\n#include <stdlib.h>\n#include <immintrin.h>\n#include <array>\n\nconstexpr double PI(3.141592653589793);\nconstexpr double SOLAR_MASS ( 4 * PI * PI );\nconstexpr double DAYS_PER_YEAR(365.24);\n\nstruct body {\n  double x[3], fill, v[3], mass;\n  constexpr body(double x0, double x1, double x2, double v0, double v1, double v2,  double Mass):\n    x{x0,x1,x2}, fill(0), v{v0,v1,v2}, mass(Mass) {}\n};\n\nclass N_Body_System\n{\n  static std::array<body,5> bodies;\n\n  void offset_momentum()\n  {\n    unsigned int k;\n    for(auto &body: bodies)\n      for(k = 0; k < 3; ++k)\n        bodies[0].v[k] -= body.v[k] * body.mass / SOLAR_MASS;\n  }\n\npublic:\n  N_Body_System()\n  {\n    offset_momentum();\n  }\n  void advance(double dt)\n  {\n    constexpr unsigned int N = ((bodies.size() - 1) * bodies.size()) / 2;\n\n    static double r[N][4];\n    static double mag[N];\n\n    unsigned int i, m;\n    __m128d dx[3], dsquared, distance, dmag;\n\n    i=0;\n    for(auto bi(bodies.begin()); bi!=bodies.end(); ++bi)\n      {\n        auto bj(bi);\n        for(++bj; bj!=bodies.end(); ++bj, ++i)\n          for (m=0; m<3; ++m)\n            r[i][m] = bi->x[m] - bj->x[m];\n      }\n\n    for (i=0; i<N; i+=2)\n      {\n        for (m=0; m<3; ++m)\n          {\n            dx[m] = _mm_loadl_pd(dx[m], &r[i][m]);\n            dx[m] = _mm_loadh_pd(dx[m], &r[i+1][m]);\n          }\n\n        dsquared = dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2];\n        distance = _mm_cvtps_pd(_mm_rsqrt_ps(_mm_cvtpd_ps(dsquared)));\n\n        for (m=0; m<2; ++m)\n          distance = distance * _mm_set1_pd(1.5)\n            - ((_mm_set1_pd(0.5) * dsquared) * distance)\n            * (distance * distance);\n\n        dmag = _mm_set1_pd(dt) / (dsquared) * distance;\n        _mm_store_pd(&mag[i], dmag);\n      }\n\n    i=0;\n    for(auto bi(bodies.begin()); bi!=bodies.end(); ++bi)\n      {\n        auto bj(bi);\n        for(++bj; bj!=bodies.end(); ++bj, ++i)\n          for(m=0; m<3; ++m)\n            {\n              const double x = r[i][m] * mag[i];\n              bi->v[m] -= x * bj->mass;\n              bj->v[m] += x * bi->mass;\n            }\n      }\n\n    for(auto &body: bodies)\n      for(m=0; m<3; ++m)\n        body.x[m] += dt * body.v[m];\n  }\n\n  double energy()\n  {\n    double e(0.0);\n    for(auto bi(bodies.cbegin()); bi!=bodies.cend(); ++bi)\n      {\n        e += bi->mass * ( bi->v[0] * bi->v[0]\n                          + bi->v[1] * bi->v[1]\n                          + bi->v[2] * bi->v[2] ) / 2.;\n\n        auto bj(bi);\n        for(++bj; bj!=bodies.end(); ++bj)\n          {\n            double distance = 0;\n            for(auto k=0; k<3; ++k)\n            {\n              const double dx = bi->x[k] - bj->x[k];\n              distance += dx * dx;\n            }\n\n            e -= (bi->mass * bj->mass) / std::sqrt(distance);\n          }\n      }\n    return e;\n  }\n};\n\n\nstd::array<body,5> N_Body_System::bodies{{\n    /* sun */\n    body(0., 0., 0. ,\n         0., 0., 0. ,\n         SOLAR_MASS),\n    /* jupiter */\n    body(4.84143144246472090e+00,\n         -1.16032004402742839e+00,\n         -1.03622044471123109e-01 ,\n         1.66007664274403694e-03 * DAYS_PER_YEAR,\n         7.69901118419740425e-03 * DAYS_PER_YEAR,\n         -6.90460016972063023e-05 * DAYS_PER_YEAR ,\n         9.54791938424326609e-04 * SOLAR_MASS\n         ),\n    /* saturn */\n    body(8.34336671824457987e+00,\n         4.12479856412430479e+00,\n         -4.03523417114321381e-01 ,\n         -2.76742510726862411e-03 * DAYS_PER_YEAR,\n         4.99852801234917238e-03 * DAYS_PER_YEAR,\n         2.30417297573763929e-05 * DAYS_PER_YEAR ,\n         2.85885980666130812e-04 * SOLAR_MASS\n         ),\n    /* uranus */\n    body(1.28943695621391310e+01,\n         -1.51111514016986312e+01,\n         -2.23307578892655734e-01 ,\n         2.96460137564761618e-03 * DAYS_PER_YEAR,\n         2.37847173959480950e-03 * DAYS_PER_YEAR,\n         -2.96589568540237556e-05 * DAYS_PER_YEAR ,\n         4.36624404335156298e-05 * SOLAR_MASS\n         ),\n    /* neptune */\n    body(1.53796971148509165e+01,\n         -2.59193146099879641e+01,\n         1.79258772950371181e-01 ,\n         2.68067772490389322e-03 * DAYS_PER_YEAR,\n         1.62824170038242295e-03 * DAYS_PER_YEAR,\n         -9.51592254519715870e-05 * DAYS_PER_YEAR ,\n         5.15138902046611451e-05 * SOLAR_MASS\n         )\n  }};\n\nint main(int , char** argv)\n{\n  int i, n = atoi(argv[1]);\n  N_Body_System system;\n\n  printf(\"%.9f\\n\", system.energy());\n  for (i = 0; i < n; ++i)\n    system.advance(0.01);\n  printf(\"%.9f\\n\", system.energy());\n\n  return 0;\n}",
        1149.017,
        20804.7
    ],
    "1": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <array>\n\nconstexpr double PI = 3.141592653589793;\nconstexpr double SOLAR_MASS = 4 * PI * PI;\nconstexpr double DAYS_PER_YEAR = 365.24;\n\nstruct body {\n    double x[3], v[3], mass;\n};\n\n// Initialize the bodies array with correct configuration\nstd::array<body, 5> bodies = {\n    body{{0, 0, 0}, {0, 0, 0}, SOLAR_MASS},\n    body{{4.84143144246472090e+00, -1.16032004402742839e+00, -1.03622044471123109e-01}, \n         {1.66007664274403694e-03 * DAYS_PER_YEAR, 7.69901118419740425e-03 * DAYS_PER_YEAR, -6.90460016972063023e-05 * DAYS_PER_YEAR}, \n         9.54791938424326609e-04 * SOLAR_MASS},\n    body{{8.34336671824457987e+00, 4.12479856412430479e+00, -4.03523417114321381e-01}, \n         {-2.76742510726862411e-03 * DAYS_PER_YEAR, 4.99852801234917238e-03 * DAYS_PER_YEAR, 2.30417297573763929e-05 * DAYS_PER_YEAR}, \n         2.85885980666130812e-04 * SOLAR_MASS},\n    body{{1.28943695621391310e+01, -1.51111514016986312e+01, -2.23307578892655734e-01}, \n         { 2.96460137564761618e-03 * DAYS_PER_YEAR, 2.37847173959480950e-03 * DAYS_PER_YEAR, -2.96589568540237556e-05 * DAYS_PER_YEAR}, \n         4.36624404335156298e-05 * SOLAR_MASS},\n    body{{1.53796971148509165e+01, -2.59193146099879641e+01, 1.79258772950371181e-01}, \n         {2.68067772490389322e-03 * DAYS_PER_YEAR, 1.62824170038242295e-03 * DAYS_PER_YEAR, -9.51592254519715870e-05 * DAYS_PER_YEAR}, \n         5.15138902046611451e-05 * SOLAR_MASS}\n};\n\nvoid offset_momentum() {\n    for (auto &body : bodies)\n        for (int k = 0; k < 3; ++k)\n            bodies[0].v[k] -= body.v[k] * body.mass / SOLAR_MASS;\n}\n\nvoid advance(double dt) {\n    for (size_t i = 0; i < bodies.size(); ++i) {\n        body &bi = bodies[i];\n        for (size_t j = i + 1; j < bodies.size(); ++j) {\n            body &bj = bodies[j];\n            double dx = bi.x[0] - bj.x[0];\n            double dy = bi.x[1] - bj.x[1];\n            double dz = bi.x[2] - bj.x[2];\n            double dist2 = dx * dx + dy * dy + dz * dz;\n            if (dist2 > 1e-10) {  // Avoid division by zero\n                double dist = std::sqrt(dist2);\n                double mag = dt / (dist2 * dist);\n\n                bi.v[0] -= dx * bj.mass * mag;\n                bi.v[1] -= dy * bj.mass * mag;\n                bi.v[2] -= dz * bj.mass * mag;\n\n                bj.v[0] += dx * bi.mass * mag;\n                bj.v[1] += dy * bi.mass * mag;\n                bj.v[2] += dz * bi.mass * mag;\n            }\n        }\n    }\n\n    for (size_t i = 0; i < bodies.size(); ++i) {\n        bodies[i].x[0] += dt * bodies[i].v[0];\n        bodies[i].x[1] += dt * bodies[i].v[1];\n        bodies[i].x[2] += dt * bodies[i].v[2];\n    }\n}\n\ndouble energy() {\n    double e = 0.0;\n    for (size_t i = 0; i < bodies.size(); ++i) {\n        body &bi = bodies[i];\n        double velocity = bi.v[0] * bi.v[0] + bi.v[1] * bi.v[1] + bi.v[2] * bi.v[2];\n        e += bi.mass * velocity / 2.0;\n\n        for (size_t j = i + 1; j < bodies.size(); ++j) {\n            body &bj = bodies[j];\n            double dx = bi.x[0] - bj.x[0];\n            double dy = bi.x[1] - bj.x[1];\n            double dz = bi.x[2] - bj.x[2];\n            double dist2 = dx * dx + dy * dy + dz * dz;\n            if (dist2 > 1e-10) {  // Avoid division by zero\n                double dist = std::sqrt(dist2);\n                e -= (bi.mass * bj.mass) / dist;\n            }\n        }\n    }\n    return e;\n}\n\nint main(int argc, char **argv) {\n    if (argc <= 1) return 1; // Ensure command-line argument is provided\n    int n = std::atoi(argv[1]);\n    offset_momentum();\n\n    std::printf(\"%.9f\\n\", energy());\n    for (int i = 0; i < n; ++i) {\n        advance(0.01);\n    }\n    std::printf(\"%.9f\\n\", energy());\n\n    return 0;\n}",
        762.963,
        14318.34
    ],
    "2": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <array>\n#include <vector>\n#include <iostream>\n\nconstexpr double PI = 3.141592653589793;\nconstexpr double SOLAR_MASS = 4 * PI * PI;\nconstexpr double DAYS_PER_YEAR = 365.24;\n\nstruct Vector3 {\n    double x, y, z;\n\n    Vector3 operator-(const Vector3 &other) const {\n        return {x - other.x, y - other.y, z - other.z};\n    }\n\n    Vector3 operator+(const Vector3 &other) const {\n        return {x + other.x, y + other.y, z + other.z};\n    }\n\n    Vector3 operator*(double scalar) const {\n        return {x * scalar, y * scalar, z * scalar};\n    }\n\n    double dot(const Vector3 &other) const {\n        return x * other.x + y * other.y + z * other.z;\n    }\n};\n\nstruct body {\n    Vector3 position, velocity;\n    double mass;\n};\n\n// Initialize the bodies array with correct configuration\nstd::array<body, 5> bodies = {\n    body{{0, 0, 0}, {0, 0, 0}, SOLAR_MASS},\n    body{{4.84143144246472090e+00, -1.16032004402742839e+00, -1.03622044471123109e-01}, \n         {1.66007664274403694e-03 * DAYS_PER_YEAR, 7.69901118419740425e-03 * DAYS_PER_YEAR, -6.90460016972063023e-05 * DAYS_PER_YEAR}, \n         9.54791938424326609e-04 * SOLAR_MASS},\n    body{{8.34336671824457987e+00, 4.12479856412430479e+00, -4.03523417114321381e-01}, \n         {-2.76742510726862411e-03 * DAYS_PER_YEAR, 4.99852801234917238e-03 * DAYS_PER_YEAR, 2.30417297573763929e-05 * DAYS_PER_YEAR}, \n         2.85885980666130812e-04 * SOLAR_MASS},\n    body{{1.28943695621391310e+01, -1.51111514016986312e+01, -2.23307578892655734e-01}, \n         { 2.96460137564761618e-03 * DAYS_PER_YEAR, 2.37847173959480950e-03 * DAYS_PER_YEAR, -2.96589568540237556e-05 * DAYS_PER_YEAR}, \n         4.36624404335156298e-05 * SOLAR_MASS},\n    body{{1.53796971148509165e+01, -2.59193146099879641e+01, 1.79258772950371181e-01}, \n         {2.68067772490389322e-03 * DAYS_PER_YEAR, 1.62824170038242295e-03 * DAYS_PER_YEAR, -9.51592254519715870e-05 * DAYS_PER_YEAR}, \n         5.15138902046611451e-05 * SOLAR_MASS}\n};\n\nvoid offset_momentum() {\n    Vector3 momentum = {0, 0, 0};\n    for (const auto &body : bodies) {\n        momentum = momentum + body.velocity * body.mass;\n    }\n    bodies[0].velocity = bodies[0].velocity - (momentum * (1.0 / SOLAR_MASS));\n}\n\nvoid advance(double dt) {\n    for (size_t i = 0; i < bodies.size(); ++i) {\n        body &bi = bodies[i];\n        for (size_t j = i + 1; j < bodies.size(); ++j) {\n            body &bj = bodies[j];\n            Vector3 dx = bi.position - bj.position;\n            double dist2 = dx.dot(dx);\n            if (dist2 > 1e-10) {  // Avoid division by zero\n                double dist = std::sqrt(dist2);\n                double mag = dt / (dist2 * dist);\n\n                Vector3 force = dx * mag;\n                bi.velocity = bi.velocity - (force * bj.mass);\n                bj.velocity = bj.velocity + (force * bi.mass);\n            }\n        }\n    }\n\n    for (auto &body : bodies) {\n        body.position = body.position + (body.velocity * dt);\n    }\n}\n\ndouble energy() {\n    double e = 0.0;\n    for (size_t i = 0; i < bodies.size(); ++i) {\n        body &bi = bodies[i];\n        double velocity = bi.velocity.dot(bi.velocity);\n        e += bi.mass * velocity / 2.0;\n\n        for (size_t j = i + 1; j < bodies.size(); ++j) {\n            body &bj = bodies[j];\n            Vector3 dx = bi.position - bj.position;\n            double dist2 = dx.dot(dx);\n            if (dist2 > 1e-10) {  // Avoid division by zero\n                double dist = std::sqrt(dist2);\n                e -= (bi.mass * bj.mass) / dist;\n            }\n        }\n    }\n    return e;\n}\n\nint main(int argc, char **argv) {\n    if (argc <= 1) return 1; // Ensure command-line argument is provided\n    int n = std::atoi(argv[1]);\n    offset_momentum();\n\n    std::printf(\"%.9f\\n\", energy());\n    for (int i = 0; i < n; ++i) {\n        advance(0.01);\n    }\n    std::printf(\"%.9f\\n\", energy());\n\n    return 0;\n}",
        1189.392,
        22240.96
    ],
    "3": [
        "#include <cstdio>\n#include <cmath>\n#include <array>\n\nconstexpr double PI = 3.141592653589793;\nconstexpr double SOLAR_MASS = 4 * PI * PI;\nconstexpr double DAYS_PER_YEAR = 365.24;\n\nstruct Vector3 {\n    double x, y, z;\n\n    Vector3 operator-(const Vector3 &other) const {\n        return {x - other.x, y - other.y, z - other.z};\n    }\n\n    Vector3 operator+(const Vector3 &other) const {\n        return {x + other.x, y + other.y, z + other.z};\n    }\n\n    Vector3 operator*(double scalar) const {\n        return {x * scalar, y * scalar, z * scalar};\n    }\n\n    double dot(const Vector3 &other) const {\n        return x * other.x + y * other.y + z * other.z;\n    }\n};\n\nstruct body {\n    Vector3 position, velocity;\n    double mass;\n};\n\nstd::array<body, 5> bodies = {\n    body{{0, 0, 0}, {0, 0, 0}, SOLAR_MASS},\n    body{{4.84143144246472090e+00, -1.16032004402742839e+00, -1.03622044471123109e-01}, \n         {1.66007664274403694e-03 * DAYS_PER_YEAR, 7.69901118419740425e-03 * DAYS_PER_YEAR, -6.90460016972063023e-05 * DAYS_PER_YEAR}, \n         9.54791938424326609e-04 * SOLAR_MASS},\n    body{{8.34336671824457987e+00, 4.12479856412430479e+00, -4.03523417114321381e-01}, \n         {-2.76742510726862411e-03 * DAYS_PER_YEAR, 4.99852801234917238e-03 * DAYS_PER_YEAR, 2.30417297573763929e-05 * DAYS_PER_YEAR}, \n         2.85885980666130812e-04 * SOLAR_MASS},\n    body{{1.28943695621391310e+01, -1.51111514016986312e+01, -2.23307578892655734e-01}, \n         { 2.96460137564761618e-03 * DAYS_PER_YEAR, 2.37847173959480950e-03 * DAYS_PER_YEAR, -2.96589568540237556e-05 * DAYS_PER_YEAR}, \n         4.36624404335156298e-05 * SOLAR_MASS},\n    body{{1.53796971148509165e+01, -2.59193146099879641e+01, 1.79258772950371181e-01}, \n         {2.68067772490389322e-03 * DAYS_PER_YEAR, 1.62824170038242295e-03 * DAYS_PER_YEAR, -9.51592254519715870e-05 * DAYS_PER_YEAR}, \n         5.15138902046611451e-05 * SOLAR_MASS}\n};\n\nvoid offset_momentum() {\n    Vector3 momentum = {0, 0, 0};\n    for (const auto &body : bodies) {\n        momentum = momentum + body.velocity * body.mass;\n    }\n    bodies[0].velocity = bodies[0].velocity - (momentum * (1.0 / SOLAR_MASS));\n}\n\nvoid advance(double dt) {\n    for (size_t i = 0; i < bodies.size(); ++i) {\n        body &bi = bodies[i];\n        for (size_t j = i + 1; j < bodies.size(); ++j) {\n            body &bj = bodies[j];\n            double dx = bi.position.x - bj.position.x;\n            double dy = bi.position.y - bj.position.y;\n            double dz = bi.position.z - bj.position.z;\n            double dist2 = dx * dx + dy * dy + dz * dz;\n\n            double invDist = 1.0 / std::sqrt(dist2);\n            double invDist3 = invDist * invDist * invDist * dt;\n\n            bi.velocity.x -= dx * bj.mass * invDist3;\n            bi.velocity.y -= dy * bj.mass * invDist3;\n            bi.velocity.z -= dz * bj.mass * invDist3;\n\n            bj.velocity.x += dx * bi.mass * invDist3;\n            bj.velocity.y += dy * bi.mass * invDist3;\n            bj.velocity.z += dz * bi.mass * invDist3;\n        }\n    }\n    for (auto &body : bodies) {\n        body.position.x += dt * body.velocity.x;\n        body.position.y += dt * body.velocity.y;\n        body.position.z += dt * body.velocity.z;\n    }\n}\n\ndouble energy() {\n    double e = 0.0;\n    for (size_t i = 0; i < bodies.size(); ++i) {\n        body &bi = bodies[i];\n        double velocity = bi.velocity.dot(bi.velocity);\n        e += bi.mass * velocity / 2.0;\n\n        for (size_t j = i + 1; j < bodies.size(); ++j) {\n            body &bj = bodies[j];\n            Vector3 dx = bi.position - bj.position;\n            double dist2 = dx.dot(dx);\n            if (dist2 > 1e-10) {\n                double dist = std::sqrt(dist2);\n                e -= (bi.mass * bj.mass) / dist;\n            }\n        }\n    }\n    return e;\n}\n\nint main(int argc, char **argv) {\n    if (argc <= 1) return 1;\n    int n = atoi(argv[1]);  // Use `atoi` without `std::`\n    offset_momentum();\n\n    std::printf(\"%.9f\\n\", energy());\n    for (int i = 0; i < n; ++i) {\n        advance(0.01);\n    }\n    std::printf(\"%.9f\\n\", energy());\n\n    return 0;\n}",
        607.518,
        11601.04
    ],
    "4": [
        "#include <cstdio>\n#include <cmath>\n#include <array>\n\nconstexpr double PI = 3.141592653589793;\nconstexpr double SOLAR_MASS = 4 * PI * PI;\nconstexpr double DAYS_PER_YEAR = 365.24;\n\nstruct Vector3 {\n    double x, y, z;\n\n    Vector3 operator-(const Vector3 &other) const {\n        return {x - other.x, y - other.y, z - other.z};\n    }\n\n    Vector3 operator+(const Vector3 &other) const {\n        return {x + other.x, y + other.y, z + other.z};\n    }\n\n    Vector3 operator*(double scalar) const {\n        return {x * scalar, y * scalar, z * scalar};\n    }\n\n    double dot(const Vector3 &other) const {\n        return x * other.x + y * other.y + z * other.z;\n    }\n};\n\nstruct body {\n    Vector3 position, velocity;\n    double mass;\n};\n\nstd::array<body, 5> bodies = {\n    body{{0, 0, 0}, {0, 0, 0}, SOLAR_MASS},\n    body{{4.84143144246472090e+00, -1.16032004402742839e+00, -1.03622044471123109e-01}, \n         {1.66007664274403694e-03 * DAYS_PER_YEAR, 7.69901118419740425e-03 * DAYS_PER_YEAR, -6.90460016972063023e-05 * DAYS_PER_YEAR}, \n         9.54791938424326609e-04 * SOLAR_MASS},\n    body{{8.34336671824457987e+00, 4.12479856412430479e+00, -4.03523417114321381e-01}, \n         {-2.76742510726862411e-03 * DAYS_PER_YEAR, 4.99852801234917238e-03 * DAYS_PER_YEAR, 2.30417297573763929e-05 * DAYS_PER_YEAR}, \n         2.85885980666130812e-04 * SOLAR_MASS},\n    body{{1.28943695621391310e+01, -1.51111514016986312e+01, -2.23307578892655734e-01}, \n         { 2.96460137564761618e-03 * DAYS_PER_YEAR, 2.37847173959480950e-03 * DAYS_PER_YEAR, -2.96589568540237556e-05 * DAYS_PER_YEAR}, \n         4.36624404335156298e-05 * SOLAR_MASS},\n    body{{1.53796971148509165e+01, -2.59193146099879641e+01, 1.79258772950371181e-01}, \n         {2.68067772490389322e-03 * DAYS_PER_YEAR, 1.62824170038242295e-03 * DAYS_PER_YEAR, -9.51592254519715870e-05 * DAYS_PER_YEAR}, \n         5.15138902046611451e-05 * SOLAR_MASS}\n};\n\nvoid offset_momentum() {\n    Vector3 momentum = {0, 0, 0};\n    for (const auto &body : bodies) {\n        momentum = momentum + body.velocity * body.mass;\n    }\n    bodies[0].velocity = bodies[0].velocity - (momentum * (1.0 / SOLAR_MASS));\n}\n\nvoid advance(double dt) {\n    for (size_t i = 0; i < bodies.size(); ++i) {\n        body &bi = bodies[i];\n        for (size_t j = i + 1; j < bodies.size(); ++j) {\n            body &bj = bodies[j];\n            Vector3 delta = bi.position - bj.position;\n            double dist2 = delta.dot(delta);\n            \n            if (dist2 > 1e-10) { // Ensure we don't compute for too small distances\n                double dist_reciprocal = 1.0 / sqrt(dist2);\n                double invDist3 = dist_reciprocal * dist_reciprocal * dist_reciprocal * dt;\n\n                Vector3 correction = delta * invDist3;\n                bi.velocity = bi.velocity - correction * bj.mass;\n                bj.velocity = bj.velocity + correction * bi.mass;\n            }\n        }\n    }\n    for (auto &body : bodies) {\n        body.position = body.position + body.velocity * dt;\n    }\n}\n\ndouble energy() {\n    double e = 0.0;\n    for (size_t i = 0; i < bodies.size(); ++i) {\n        body &bi = bodies[i];\n        double velocity = bi.velocity.dot(bi.velocity);\n        e += bi.mass * velocity / 2.0;\n\n        for (size_t j = i + 1; j < bodies.size(); ++j) {\n            body &bj = bodies[j];\n            Vector3 dx = bi.position - bj.position;\n            double dist2 = dx.dot(dx);\n            if (dist2 > 1e-10) {\n                double dist = std::sqrt(dist2);\n                e -= (bi.mass * bj.mass) / dist;\n            }\n        }\n    }\n    return e;\n}\n\nint main(int argc, char **argv) {\n    if (argc <= 1) return 1;\n    int n = atoi(argv[1]);\n    offset_momentum();\n\n    std::printf(\"%.9f\\n\", energy());\n    for (int i = 0; i < n; ++i) {\n        advance(0.01);\n    }\n    std::printf(\"%.9f\\n\", energy());\n\n    return 0;\n}",
        1192.536,
        22574.54
    ],
    "5": [
        "#include <cstdio>\n#include <cmath>\n#include <array>\n\nconstexpr double PI = 3.141592653589793;\nconstexpr double SOLAR_MASS = 4 * PI * PI;\nconstexpr double DAYS_PER_YEAR = 365.24;\n\nstruct Vector3 {\n    double x, y, z;\n\n    Vector3 operator-(const Vector3 &other) const {\n        return {x - other.x, y - other.y, z - other.z};\n    }\n\n    Vector3 operator+(const Vector3 &other) const {\n        return {x + other.x, y + other.y, z + other.z};\n    }\n\n    Vector3 operator*(double scalar) const {\n        return {x * scalar, y * scalar, z * scalar};\n    }\n\n    double dot(const Vector3 &other) const {\n        return x * other.x + y * other.y + z * other.z;\n    }\n};\n\nstruct body {\n    Vector3 position, velocity;\n    double mass;\n};\n\nstd::array<body, 5> bodies = {\n    body{{0, 0, 0}, {0, 0, 0}, SOLAR_MASS},\n    body{{4.84143144246472090e+00, -1.16032004402742839e+00, -1.03622044471123109e-01}, \n         {1.66007664274403694e-03 * DAYS_PER_YEAR, 7.69901118419740425e-03 * DAYS_PER_YEAR, -6.90460016972063023e-05 * DAYS_PER_YEAR}, \n         9.54791938424326609e-04 * SOLAR_MASS},\n    body{{8.34336671824457987e+00, 4.12479856412430479e+00, -4.03523417114321381e-01}, \n         {-2.76742510726862411e-03 * DAYS_PER_YEAR, 4.99852801234917238e-03 * DAYS_PER_YEAR, 2.30417297573763929e-05 * DAYS_PER_YEAR}, \n         2.85885980666130812e-04 * SOLAR_MASS},\n    body{{1.28943695621391310e+01, -1.51111514016986312e+01, -2.23307578892655734e-01}, \n         { 2.96460137564761618e-03 * DAYS_PER_YEAR, 2.37847173959480950e-03 * DAYS_PER_YEAR, -2.96589568540237556e-05 * DAYS_PER_YEAR}, \n         4.36624404335156298e-05 * SOLAR_MASS},\n    body{{1.53796971148509165e+01, -2.59193146099879641e+01, 1.79258772950371181e-01}, \n         {2.68067772490389322e-03 * DAYS_PER_YEAR, 1.62824170038242295e-03 * DAYS_PER_YEAR, -9.51592254519715870e-05 * DAYS_PER_YEAR}, \n         5.15138902046611451e-05 * SOLAR_MASS}\n};\n\nvoid offset_momentum() {\n    Vector3 momentum = {0, 0, 0};\n    for (const auto &body : bodies) {\n        momentum = momentum + body.velocity * body.mass;\n    }\n    bodies[0].velocity = bodies[0].velocity - (momentum * (1.0 / SOLAR_MASS));\n}\n\nvoid advance(double dt) {\n    for (size_t i = 0; i < bodies.size(); ++i) {\n        body &bi = bodies[i];\n        for (size_t j = i + 1; j < bodies.size(); ++j) {\n            body &bj = bodies[j];\n            Vector3 delta = bi.position - bj.position;\n            double dist2 = delta.dot(delta);\n\n            if (dist2 > 1e-10) {  // Ensure we don't compute for too small distances\n                double dist = sqrt(dist2);\n                double invDist3 = dt / (dist2 * dist);\n\n                Vector3 correction = delta * invDist3;\n                bi.velocity = bi.velocity - correction * bj.mass;\n                bj.velocity = bj.velocity + correction * bi.mass;\n            }\n        }\n    }\n    for (auto &body : bodies) {\n        body.position = body.position + body.velocity * dt;\n    }\n}\n\ndouble energy() {\n    double e = 0.0;\n    for (size_t i = 0; i < bodies.size(); ++i) {\n        body &bi = bodies[i];\n        double velocity2 = bi.velocity.dot(bi.velocity);\n        e += bi.mass * velocity2 / 2.0;\n\n        for (size_t j = i + 1; j < bodies.size(); ++j) {\n            body &bj = bodies[j];\n            Vector3 dx = bi.position - bj.position;\n            double dist2 = dx.dot(dx);\n            if (dist2 > 1e-10) {\n                double dist = std::sqrt(dist2);\n                e -= (bi.mass * bj.mass) / dist;\n            }\n        }\n    }\n    return e;\n}\n\nint main(int argc, char **argv) {\n    if (argc <= 1) return 1;\n    int n = atoi(argv[1]);\n    offset_momentum();\n\n    std::printf(\"%.9f\\n\", energy());\n    for (int i = 0; i < n; ++i) {\n        advance(0.01);\n    }\n    std::printf(\"%.9f\\n\", energy());\n\n    return 0;\n}",
        1161.428,
        21669.76
    ]
}