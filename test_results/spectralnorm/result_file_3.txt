{
    "0": [
        "// The Computer Language Benchmarks Game\n// http://benchmarksgame.alioth.debian.org/\n//\n// Original C contributed by Sebastien Loisel\n// Conversion to C++ by Jon Harrop\n// OpenMP parallelize by The Anh Tran\n// Add SSE by The Anh Tran\n// Additional SSE optimization by Krzysztof Jakubowski\n\n// g++ -pipe -O3 -march=native -fopenmp -mfpmath=sse -msse2 \\\n//     ./spec.c++ -o ./spec.run\n\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <emmintrin.h>\n\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei? i : j) + 1;\n}\n\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst,\n                int begin, int end, int length) {\n    int i = begin;\n\n    for(; i + 1 < end; i += 2) {\n        __m128d sum = _mm_set_pd(\n\t\t\tsrc[0] / double(Index<modei>(i + 1, 0)),\n\t\t\tsrc[0] / double(Index<modei>(i + 0, 0)));\n    \n\t\t__m128d ti = modei?\n\t\t\t_mm_set_pd(i + 1, i + 0) :\n\t\t\t_mm_set_pd(i + 2, i + 1);\t\n\t\t__m128d last = _mm_set_pd(\n\t\t\tIndex<modei>(i + 1, 0),\n\t\t\tIndex<modei>(i + 0, 0));\n\n        for(int j = 1; j < length; j++) {\n\t\t\t__m128d idx = last + ti + _mm_set1_pd(j);\n\t\t\tlast = idx;\n            sum = sum + _mm_set1_pd(src[j]) / idx;\n        }\n\n        _mm_storeu_pd(dst + i + 0, sum);\n    }\n    for(; i < end; i++) {\n        double sum = 0;\n        for (int j = 0; j < length; j++)\n            sum += src[j] / double(Index<modei>(i, j));\n        dst[i] = sum;\n    }\n\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp,\n                   int begin, int end, int N) {\n    EvalATimesU (src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\ndouble spectral_game(int N) {\n    __attribute__((aligned(16))) double u[N];\n    __attribute__((aligned(16))) double v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        // this block will be executed by NUM_THREADS\n        // variable declared in this block is private for each thread\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        // calculate each thread's working range [r1 .. r2) => static schedule\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;\n\n        for(int i = begin; i < end; i++)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n    \n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        31.52,
        176.164
    ],
    "1": [
        "#include <iostream>  // For std::cout\n#include <vector>    // For std::vector\n#include <cmath>     // For std::sqrt\n#include <cstdlib>   // For std::atoi\n#include <cstdio>    // For std::printf\n#include <sched.h>   // For CPU scheduling functions\n#include <omp.h>     // For OpenMP\n#include <emmintrin.h>  // SSE2\n#ifdef __AVX__\n#include <immintrin.h>  // Include AVX for possible use\n#endif\n\n// Template for index calculation based on the mode(bool modei)\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei ? i : j) + 1;\n}\n\n// Function to evaluate part of the matrix-vector product\n// with specialization for SSE and optional AVX if available\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst,\n              int begin, int end, int length) {\n    int i = begin;\n\n#if defined(__AVX__)\n    // Use AVX if available (4 double registers)\n    for (; i + 3 < end; i += 4) {\n        __m256d sum = _mm256_set_pd(\n            src[0] / double(Index<modei>(i + 3, 0)),\n            src[0] / double(Index<modei>(i + 2, 0)),\n            src[0] / double(Index<modei>(i + 1, 0)),\n            src[0] / double(Index<modei>(i + 0, 0)));\n        \n        __m256d ti = modei ?\n            _mm256_set_pd(i + 3, i + 2, i + 1, i + 0) :\n            _mm256_set_pd(i + 4, i + 3, i + 2, i + 1);\n\n        __m256d last = _mm256_set_pd(\n            Index<modei>(i + 3, 0),\n            Index<modei>(i + 2, 0),\n            Index<modei>(i + 1, 0),\n            Index<modei>(i + 0, 0));\n\n        for (int j = 1; j < length; j++) {\n            __m256d addition = _mm256_set1_pd(double(j));\n            __m256d idx = _mm256_add_pd(last, _mm256_add_pd(ti, addition));\n            last = idx;\n            __m256d src_broadcast = _mm256_set1_pd(src[j]);\n            sum = _mm256_add_pd(sum, _mm256_div_pd(src_broadcast, idx));\n        }\n        _mm256_storeu_pd(dst + i, sum);\n    }\n#endif\n    // Fallback to SSE2 if AVX is not available or for remainder\n    for(; i + 1 < end; i += 2) {\n        __m128d sum = _mm_set_pd(\n            src[0] / double(Index<modei>(i + 1, 0)),\n            src[0] / double(Index<modei>(i + 0, 0)));\n    \n        __m128d ti = modei?\n            _mm_set_pd(i + 1, i + 0) :\n            _mm_set_pd(i + 2, i + 1);\n        __m128d last = _mm_set_pd(\n            Index<modei>(i + 1, 0),\n            Index<modei>(i + 0, 0));\n\n        for(int j = 1; j < length; j++) {\n            __m128d idx = _mm_add_pd(last, _mm_add_pd(ti, _mm_set1_pd(double(j))));\n            last = idx;\n            sum = _mm_add_pd(sum, _mm_div_pd(_mm_set1_pd(src[j]), idx));\n        }\n\n        _mm_storeu_pd(dst + i + 0, sum);\n    }\n    for (; i < end; i++) {\n        double sum = 0;\n        for (int j = 0; j < length; j++)\n            sum += src[j] / double(Index<modei>(i, j));\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<true>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<false>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp, int begin, int end, int N) {\n    EvalATimesU(src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\n// Spectral game function\n// Calculates the spectral norm of a given reversed-index matrix\n// using optimized parallel-processing methods\ndouble spectral_game(int N) {\n    __attribute__((aligned(16))) double u[N];\n    __attribute__((aligned(16))) double v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        // Establishing a range for each thread to work on\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount - 1)) ? (begin + chunk) : N;\n\n        // Initialize components of u to unity\n        for (int i = begin; i < end; i++)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        // Perform iterations for convergence\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n\n        // The accumulate step to combine results across threads\n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        // Safeguard the accumulation using atomic or critical directive\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    return std::sqrt(vBv / vv);  // Returning the calculated spectral norm\n}\n\n// Program execution entry point\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? std::atoi(argv[1]) : 2000);\n    std::printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}\n",
        37.609,
        215.713
    ],
    "2": [
        "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n\n// Maintain the matrix index calculation consistent with original logic.\ninline int Index(int i, int j) {\n    return (i + j) * (i + j + 1) / 2 + i;\n}\n\n// Maintain these evaluation function behaviors ensuring correct accumulation and index usage\nvoid EvalPart(const double* src, double* dst, int begin, int end, int length) {\n    for (int i = begin; i < end; ++i) {\n        double sum = 0.0;\n        for (int j = 0; j < length; ++j) {\n            sum += src[j] / static_cast<double>(Index(i, j) + 1);\n        }\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(const double* src, double* dst, int begin, int end, int N) {\n    for (int i = begin; i < end; ++i) {\n        double sum = 0.0;\n        for (int j = 0; j < N; ++j) {\n            sum += src[j] / static_cast<double>(Index(i, j) + 1);\n        }\n        dst[i] = sum;\n    }\n}\n\nvoid EvalAtTimesU(const double* src, double* dst, int begin, int end, int N) {\n    for (int i = begin; i < end; ++i) {\n        double sum = 0.0;\n        for (int j = 0; j < N; ++j) {\n            sum += src[j] / static_cast<double>(Index(j, i) + 1);\n        }\n        dst[i] = sum;\n    }\n}\n\nvoid EvalAtATimesU(double* src, double* dst, double* tmp, int N) {\n    EvalATimesU(src, tmp, 0, N, N);\n    EvalAtTimesU(tmp, dst, 0, N, N);\n}\n\ndouble spectral_game(int N) {\n    std::vector<double> u(N, 1.0);\n    std::vector<double> v(N, 0.0);\n    std::vector<double> tmp(N, 0.0);\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    for (int iteration = 0; iteration < 10; ++iteration) {\n        EvalAtATimesU(u.data(), v.data(), tmp.data(), N);\n        EvalAtATimesU(v.data(), u.data(), tmp.data(), N);\n    }\n\n    for (int i = 0; i < N; ++i) {\n        vBv += u[i] * v[i];\n        vv += v[i] * v[i];\n    }\n\n    return std::sqrt(vBv / vv);\n}\n\nint main(int argc, char* argv[]) {\n    int N = (argc > 1) ? std::atoi(argv[1]) : 2000;\n    std::printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        291.89,
        5631.816
    ],
    "3": [
        "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n\ninline double A(int i, int j) {\n    return 1.0 / ((i + j) * (i + j + 1) / 2 + i + 1);\n}\n\nvoid multiply_AtAv(const std::vector<double> &v, std::vector<double> &out, int N) {\n    std::vector<double> u(N, 0.0);\n    for (int i = 0; i < N; ++i) {\n        double sum_v = 0.0;\n        for (int j = 0; j < N; ++j) sum_v += A(j, i) * v[j];\n        u[i] = sum_v;\n    }\n    for (int i = 0; i < N; ++i) {\n        double sum_u = 0.0;\n        for (int j = 0; j < N; ++j) sum_u += A(i, j) * u[j];\n        out[i] = sum_u;\n    }\n}\n\nvoid multiply_Atv(const std::vector<double> &v, std::vector<double> &out, int N) {\n    for (int i = 0; i < N; ++i) {\n        double sum = 0.0;\n        for (int j = 0; j < N; ++j) sum += A(j, i) * v[j];\n        out[i] = sum;\n    }\n}\n\nvoid multiply_Av(const std::vector<double> &v, std::vector<double> &out, int N) {\n    for (int i = 0; i < N; ++i) {\n        double sum = 0.0;\n        for (int j = 0; j < N; ++j) sum += A(i, j) * v[j];\n        out[i] = sum;\n    }\n}\n\nvoid computeSpectralGame(std::vector<double> &u, std::vector<double> &v, int N) {\n    for (int i = 0; i < 10; ++i) {\n        multiply_AtAv(u, v, N);\n        multiply_AtAv(v, u, N);\n    }\n}\n\ndouble compute_spectral_norm(int N) {\n    std::vector<double> u(N, 1.0);\n    std::vector<double> v(N, 0.0);\n\n    computeSpectralGame(u, v, N);\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    for (int i = 0; i < N; ++i) {\n        vBv += u[i] * v[i];\n        vv += v[i] * v[i];\n    }\n\n    return std::sqrt(vBv / vv);\n}\n\nint main(int argc, char* argv[]) {\n    int N = (argc > 1) ? std::atoi(argv[1]) : 2000;\n    std::printf(\"%.9f\\n\", compute_spectral_norm(N));\n    return 0;\n}",
        451.05,
        8683.678
    ],
    "4": [
        "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <omp.h>\n\ninline double A(int i, int j) {\n    return 1.0 / ((i + j) * (i + j + 1) / 2 + i + 1);\n}\n\nvoid multiply_AtAv(const std::vector<double> &v, std::vector<double> &out, int N) {\n    std::vector<double> u(N, 0.0);\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        double sum_v = 0.0;\n        for (int j = 0; j < N; ++j) sum_v += A(j, i) * v[j];\n        u[i] = sum_v;\n    }\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        double sum_u = 0.0;\n        for (int j = 0; j < N; ++j) sum_u += A(i, j) * u[j];\n        out[i] = sum_u;\n    }\n}\n\nvoid multiply_Atv(const std::vector<double> &v, std::vector<double> &out, int N) {\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        double sum = 0.0;\n        for (int j = 0; j < N; ++j) sum += A(j, i) * v[j];\n        out[i] = sum;\n    }\n}\n\nvoid multiply_Av(const std::vector<double> &v, std::vector<double> &out, int N) {\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        double sum = 0.0;\n        for (int j = 0; j < N; ++j) sum += A(i, j) * v[j];\n        out[i] = sum;\n    }\n}\n\nvoid computeSpectralGame(std::vector<double> &u, std::vector<double> &v, int N) {\n    for (int i = 0; i < 10; ++i) {\n        multiply_AtAv(u, v, N);\n        multiply_AtAv(v, u, N);\n    }\n}\n\ndouble compute_spectral_norm(int N) {\n    std::vector<double> u(N, 1.0);\n    std::vector<double> v(N, 0.0);\n\n    computeSpectralGame(u, v, N);\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel for reduction(+:vBv,vv)\n    for (int i = 0; i < N; ++i) {\n        vBv += u[i] * v[i];\n        vv += v[i] * v[i];\n    }\n\n    return std::sqrt(vBv / vv);\n}\n\nint main(int argc, char* argv[]) {\n    int N = (argc > 1) ? std::atoi(argv[1]) : 2000;\n    std::printf(\"%.9f\\n\", compute_spectral_norm(N));\n    return 0;\n}",
        76.078,
        415.529
    ],
    "5": [
        "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <omp.h>\n\ninline double A(int i, int j) {\n    return 1.0 / ((i + j) * (i + j + 1) / 2 + i + 1);\n}\n\nvoid multiply_AtAv(const std::vector<double> &v, std::vector<double> &out, int N) {\n    std::vector<double> u(N, 0.0);\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        double sum = 0.0;\n        for (int j = 0; j < N; ++j) {\n            sum += A(i, j) * v[j];\n        }\n        u[i] = sum;\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        double sum = 0.0;\n        for (int j = 0; j < N; ++j) {\n            sum += A(j, i) * u[j];\n        }\n        out[i] = sum;\n    }\n}\n\nvoid computeSpectralGame(std::vector<double> &u, std::vector<double> &v, int N) {\n    for (int i = 0; i < 10; ++i) {\n        multiply_AtAv(u, v, N);\n        multiply_AtAv(v, u, N);\n    }\n}\n\ndouble compute_spectral_norm(int N) {\n    std::vector<double> u(N, 1.0);\n    std::vector<double> v(N, 0.0);\n\n    computeSpectralGame(u, v, N);\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel for reduction(+:vBv,vv)\n    for (int i = 0; i < N; ++i) {\n        vBv += u[i] * v[i];\n        vv += v[i] * v[i];\n    }\n\n    return std::sqrt(vBv / vv);\n}\n\nint main(int argc, char* argv[]) {\n    int N = (argc > 1) ? std::atoi(argv[1]) : 2000;\n    std::printf(\"%.9f\\n\", compute_spectral_norm(N));\n    return 0;\n}",
        74.205,
        401.117
    ]
}

Program executed for 7.797388 minutes