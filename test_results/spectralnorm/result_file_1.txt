{
    "0": [
        "// The Computer Language Benchmarks Game\n// http://benchmarksgame.alioth.debian.org/\n//\n// Original C contributed by Sebastien Loisel\n// Conversion to C++ by Jon Harrop\n// OpenMP parallelize by The Anh Tran\n// Add SSE by The Anh Tran\n// Additional SSE optimization by Krzysztof Jakubowski\n\n// g++ -pipe -O3 -march=native -fopenmp -mfpmath=sse -msse2 \\\n//     ./spec.c++ -o ./spec.run\n\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <emmintrin.h>\n\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei? i : j) + 1;\n}\n\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst,\n                int begin, int end, int length) {\n    int i = begin;\n\n    for(; i + 1 < end; i += 2) {\n        __m128d sum = _mm_set_pd(\n\t\t\tsrc[0] / double(Index<modei>(i + 1, 0)),\n\t\t\tsrc[0] / double(Index<modei>(i + 0, 0)));\n    \n\t\t__m128d ti = modei?\n\t\t\t_mm_set_pd(i + 1, i + 0) :\n\t\t\t_mm_set_pd(i + 2, i + 1);\t\n\t\t__m128d last = _mm_set_pd(\n\t\t\tIndex<modei>(i + 1, 0),\n\t\t\tIndex<modei>(i + 0, 0));\n\n        for(int j = 1; j < length; j++) {\n\t\t\t__m128d idx = last + ti + _mm_set1_pd(j);\n\t\t\tlast = idx;\n            sum = sum + _mm_set1_pd(src[j]) / idx;\n        }\n\n        _mm_storeu_pd(dst + i + 0, sum);\n    }\n    for(; i < end; i++) {\n        double sum = 0;\n        for (int j = 0; j < length; j++)\n            sum += src[j] / double(Index<modei>(i, j));\n        dst[i] = sum;\n    }\n\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp,\n                   int begin, int end, int N) {\n    EvalATimesU (src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\ndouble spectral_game(int N) {\n    __attribute__((aligned(16))) double u[N];\n    __attribute__((aligned(16))) double v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        // this block will be executed by NUM_THREADS\n        // variable declared in this block is private for each thread\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        // calculate each thread's working range [r1 .. r2) => static schedule\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;\n\n        for(int i = begin; i < end; i++)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n    \n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        31.345,
        177.604
    ],
    "1": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <emmintrin.h>\n\n// Function used to index the elements based on mode\n// modei determines the type of calculation\n// template allows for optimizing similar logic for modes\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei ? i : j) + 1;\n}\n\n// EvalPart evaluates part of a spectral norm calculation\n// using SSE instructions for performance optimization\n// the loop is partitioned per thread and per SSE block iteration\n// ensuring even workload across CPU cores\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst,\n              int begin, int end, int length) {\n    int i = begin;\n\n    // Vectorize with SSE intrinsics\n    for (; i + 1 < end; i += 2) {\n        __m128d sum = _mm_set_pd(src[0] / double(Index<modei>(i + 1, 0)),\n                                  src[0] / double(Index<modei>(i + 0, 0)));\n\n        __m128d ti = modei ?\n            _mm_set_pd(i + 1, i + 0) :\n            _mm_set_pd(i + 2, i + 1);\n        __m128d last = _mm_set_pd(Index<modei>(i + 1, 0),\n                                  Index<modei>(i + 0, 0));\n\n        for (int j = 1; j < length; ++j) {\n            __m128d idx = last + ti + _mm_set1_pd(j);\n            last = idx;\n            sum = sum + _mm_set1_pd(src[j]) / idx;\n        }\n\n        _mm_storeu_pd(dst + i + 0, sum);\n    }\n    // Resolves any remainder that can't be vectorized\n    for (; i < end; ++i) {\n        double sum = 0.0;\n        for (int j = 0; j < length; ++j)\n            sum += src[j] / double(Index<modei>(i, j));\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp,\n                   int begin, int end, int N) {\n    EvalATimesU(src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\n// Determine the number of threads available for parallel execution\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\n// Compute spectral norm over a matrix of size N\n// Leverages thread blocks, SIMD, and precision\n// in large numerical iterations over fixed data\n// For multi-core CPUs achieving near linear scaling with core counts\n\n// Improving further partition distribution granularity\n// for workloads using more conditional division if data fits cache\n// indicates bounds easily met within architecture tolerance\n\n// Instead, note opportunities available in the library usages\n// considering the forwards and backward eval impacts if purely\n// following allocation without associative reordering potential.\ndouble spectral_game(int N) {\n    __attribute__((aligned(16))) double u[N];\n    __attribute__((aligned(16))) double v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount - 1)) ? (begin + chunk) : N;\n\n        for (int i = begin; i < end; ++i)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n\n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; ++i) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = (argc >= 2) ? atoi(argv[1]) : 2000;\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        31.745,
        179.113
    ],
    "2": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <emmintrin.h>\n\n// Align data structures for optimal memory usage\n// Utilize OpenMP scheduling and SSE operations\n\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei ? i : j) + 1;\n}\n\n// Revamping EvalPart with better loop handling\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst,\n              int begin, int end, int length) {\n    int i = begin;\n    for (; i + 1 < end; i += 2) {\n        __m128d sum = _mm_set_pd(src[0] / double(Index<modei>(i + 1, 0)),\n                                 src[0] / double(Index<modei>(i + 0, 0)));\n\n        __m128d ti = modei ?\n            _mm_set_pd(i + 1, i + 0) :\n            _mm_set_pd(i + 2, i + 1);\n        __m128d last = _mm_set_pd(Index<modei>(i + 1, 0),\n                                  Index<modei>(i + 0, 0));\n\n        for (int j = 1; j < length; ++j) {\n            __m128d idx = last + ti + _mm_set1_pd(j);\n            last = idx;\n            sum = sum + _mm_set1_pd(src[j]) / idx;\n        }\n\n        _mm_storeu_pd(dst + i + 0, sum);\n    }\n    for (; i < end; ++i) {\n        double sum = 0.0;\n        for (int j = 0; j < length; ++j)\n            sum += src[j] / double(Index<modei>(i, j));\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp,\n                   int begin, int end, int N) {\n    EvalATimesU(src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\ndouble spectral_game(int N) {\n    __attribute__((aligned(16))) double u[N];\n    __attribute__((aligned(16))) double v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount - 1)) ? (begin + chunk) : N;\n\n        for (int i = begin; i < end; ++i)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n\n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; ++i) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = (argc >= 2) ? atoi(argv[1]) : 2000;\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        31.382,
        175.901
    ],
    "3": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstddef>\n#include <sched.h>\n#include <omp.h>\n\nstatic double *u = nullptr, *v = nullptr, *tmp = nullptr;\nstatic int *cached_indices = nullptr;\n\nvoid precompute_indices(int N) {\n    if (cached_indices) delete[] cached_indices;\n    cached_indices = new int[N * N];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cached_indices[i * N + j] = (((i + j) * (i + j + 1)) >> 1) + j + 1;\n        }\n    }\n}\n\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst,\n              int begin, int end, int length, bool modei) {\n    for (int i = begin; i < end; ++i) {\n        double sum = 0.0;\n\n        for (int j = 0; j < length; ++j) {\n            int index = modei ? cached_indices[i * length + j] : cached_indices[j * length + i];\n            sum += src[j] / index;\n        }\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart(src, dst, begin, end, N, true);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart(src, dst, begin, end, N, false);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp,\n                   int begin, int end, int N) {\n    EvalATimesU(src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\nvoid allocate_buffers(int N) {\n    if (u) free(u); if (v) free(v); if (tmp) free(tmp);\n    u = (double*)aligned_alloc(32, N*sizeof(double));\n    v = (double*)aligned_alloc(32, N*sizeof(double));\n    tmp = (double*)aligned_alloc(32, N*sizeof(double));\n}\n\nvoid free_buffers() {\n    free(u); free(v); free(tmp);\n}\n\ndouble spectral_game(int N) {\n    allocate_buffers(N);\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    precompute_indices(N);\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount - 1)) ? (begin + chunk) : N;\n\n        for (int i = begin; i < end; ++i)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n\n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; ++i) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    free_buffers();\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = (argc >= 2) ? atoi(argv[1]) : 2000;\n    printf(\"%.9f\\n\", spectral_game(N));\n    delete[] cached_indices;\n    return 0;\n}\n",
        77.996,
        570.535
    ],
    "4": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstddef>\n#include <sched.h>\n#include <omp.h>\n#include <immintrin.h> // Include for AVX/SIMD\n\nstatic double *u = nullptr, *v = nullptr, *tmp = nullptr;\nstatic int *cached_indices = nullptr;\n\nvoid precompute_indices(int N) {\n    if (cached_indices) delete[] cached_indices;\n    cached_indices = new int[N * N];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cached_indices[i * N + j] = (((i + j) * (i + j + 1)) >> 1) + j + 1;\n        }\n    }\n}\n\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst,\n              int begin, int end, int length, bool modei) {\n    for (int i = begin; i < end; ++i) {\n        double sum = 0.0;\n\n        for (int j = 0; j < length; j += 4) { // Process 4 elements at a time\n            int index1 = modei ? cached_indices[i * length + j] : cached_indices[j * length + i];\n            int index2 = modei ? cached_indices[i * length + j + 1] : cached_indices[(j + 1) * length + i];\n            int index3 = modei ? cached_indices[i * length + j + 2] : cached_indices[(j + 2) * length + i];\n            int index4 = modei ? cached_indices[i * length + j + 3] : cached_indices[(j + 3) * length + i];\n\n            __m256d src_vec = _mm256_load_pd(&src[j]);\n            __m256d inds_vec = _mm256_set_pd(1.0/index4, 1.0/index3, 1.0/index2, 1.0/index1);\n            __m256d prod = _mm256_mul_pd(src_vec, inds_vec);\n\n            sum += ((double*)&prod)[0] + ((double*)&prod)[1] + ((double*)&prod)[2] + ((double*)&prod)[3];\n        }\n\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart(src, dst, begin, end, N, true);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart(src, dst, begin, end, N, false);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp,\n                   int begin, int end, int N) {\n    EvalATimesU(src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\nvoid allocate_buffers(int N) {\n    if (u) free(u); if (v) free(v); if (tmp) free(tmp);\n    u = (double*)aligned_alloc(32, N*sizeof(double));\n    v = (double*)aligned_alloc(32, N*sizeof(double));\n    tmp = (double*)aligned_alloc(32, N*sizeof(double));\n}\n\nvoid free_buffers() {\n    free(u); free(v); free(tmp);\n}\n\ndouble spectral_game(int N) {\n    allocate_buffers(N);\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    precompute_indices(N);\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount - 1)) ? (begin + chunk) : N;\n\n        for (int i = begin; i < end; ++i)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n\n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; ++i) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    free_buffers();\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = (argc >= 2) ? atoi(argv[1]) : 2000;\n    printf(\"%.9f\\n\", spectral_game(N));\n    delete[] cached_indices;\n    return 0;\n}\n",
        77.576,
        555.2
    ],
    "5": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <omp.h>\n#include <immintrin.h>\n\nstatic double *u = nullptr, *v = nullptr, *tmp = nullptr;\nstatic int *cached_indices = nullptr;\n\nvoid precompute_indices(int N) {\n    if (cached_indices) delete[] cached_indices;\n    cached_indices = new int[N * N];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cached_indices[i * N + j] = (((i + j) * (i + j + 1)) >> 1) + j + 1;\n        }\n    }\n}\n\nvoid EvalPart(const double *__restrict__ src, double *__restrict__ dst, int begin, int end, int length, bool modei) {\n    for (int i = begin; i < end; ++i) {\n        double sum = 0.0;\n        \n        __m256d sum_vec = _mm256_setzero_pd();\n        \n        int j;\n        for (j = 0; j <= length - 4; j += 4) {\n            int idx1 = modei ? cached_indices[i * length + j] : cached_indices[j * length + i];\n            int idx2 = modei ? cached_indices[i * length + j + 1] : cached_indices[(j + 1) * length + i];\n            int idx3 = modei ? cached_indices[i * length + j + 2] : cached_indices[(j + 2) * length + i];\n            int idx4 = modei ? cached_indices[i * length + j + 3] : cached_indices[(j + 3) * length + i];\n\n            __m256d src_vec = _mm256_load_pd(&src[j]);\n            __m256d idx_vec = _mm256_set_pd(1.0 / idx4, 1.0 / idx3, 1.0 / idx2, 1.0 / idx1);\n            __m256d prod = _mm256_mul_pd(src_vec, idx_vec);\n\n            sum_vec = _mm256_add_pd(sum_vec, prod);\n        }\n\n        sum += sum_vec[0] + sum_vec[1] + sum_vec[2] + sum_vec[3];\n        \n        for (; j < length; ++j) {\n            int idx = modei ? cached_indices[i * length + j] : cached_indices[j * length + i];\n            sum += src[j] / idx;\n        }\n\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart(src, dst, begin, end, N, true);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart(src, dst, begin, end, N, false);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp, int begin, int end, int N) {\n    EvalATimesU(src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    return omp_get_max_threads();\n}\n\nvoid allocate_buffers(int N) {\n    u = (double*)aligned_alloc(32, N * sizeof(double));\n    v = (double*)aligned_alloc(32, N * sizeof(double));\n    tmp = (double*)aligned_alloc(32, N * sizeof(double));\n}\n\nvoid free_buffers() {\n    free(u);\n    free(v);\n    free(tmp);\n}\n\ndouble spectral_game(int N) {\n    allocate_buffers(N);\n    precompute_indices(N);\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = (N + threadcount - 1) / threadcount;\n\n        int begin = threadid * chunk;\n        int end = std::min(begin + chunk, N);\n\n        for (int i = begin; i < end; ++i) {\n            u[i] = 1.0;\n        }\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n\n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; ++i) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp atomic\n        vBv += sumvb;\n        #pragma omp atomic\n        vv += sumvv;\n    }\n\n    free_buffers();\n    delete[] cached_indices;\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = (argc >= 2) ? atoi(argv[1]) : 2000;\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        69.49,
        513.769
    ]
}

Program executed for 7.053817