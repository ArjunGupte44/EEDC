{
    "0": [
        "// The Computer Language Benchmarks Game\n// http://benchmarksgame.alioth.debian.org/\n//\n// Original C contributed by Sebastien Loisel\n// Conversion to C++ by Jon Harrop\n// OpenMP parallelize by The Anh Tran\n// Add SSE by The Anh Tran\n// Additional SSE optimization by Krzysztof Jakubowski\n\n// g++ -pipe -O3 -march=native -fopenmp -mfpmath=sse -msse2 \\\n//     ./spec.c++ -o ./spec.run\n\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <emmintrin.h>\n\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei? i : j) + 1;\n}\n\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst,\n                int begin, int end, int length) {\n    int i = begin;\n\n    for(; i + 1 < end; i += 2) {\n        __m128d sum = _mm_set_pd(\n\t\t\tsrc[0] / double(Index<modei>(i + 1, 0)),\n\t\t\tsrc[0] / double(Index<modei>(i + 0, 0)));\n    \n\t\t__m128d ti = modei?\n\t\t\t_mm_set_pd(i + 1, i + 0) :\n\t\t\t_mm_set_pd(i + 2, i + 1);\t\n\t\t__m128d last = _mm_set_pd(\n\t\t\tIndex<modei>(i + 1, 0),\n\t\t\tIndex<modei>(i + 0, 0));\n\n        for(int j = 1; j < length; j++) {\n\t\t\t__m128d idx = last + ti + _mm_set1_pd(j);\n\t\t\tlast = idx;\n            sum = sum + _mm_set1_pd(src[j]) / idx;\n        }\n\n        _mm_storeu_pd(dst + i + 0, sum);\n    }\n    for(; i < end; i++) {\n        double sum = 0;\n        for (int j = 0; j < length; j++)\n            sum += src[j] / double(Index<modei>(i, j));\n        dst[i] = sum;\n    }\n\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp,\n                   int begin, int end, int N) {\n    EvalATimesU (src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\ndouble spectral_game(int N) {\n    __attribute__((aligned(16))) double u[N];\n    __attribute__((aligned(16))) double v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        // this block will be executed by NUM_THREADS\n        // variable declared in this block is private for each thread\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        // calculate each thread's working range [r1 .. r2) => static schedule\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;\n\n        for(int i = begin; i < end; i++)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n    \n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        31.193,
        175.88
    ],
    "1": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <immintrin.h> // Use AVX instructions\n\n// Define Index as before\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei? i : j) + 1;\n}\n\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst,\n                int begin, int end, int length) {\n    int i = begin;\n\n    for(; i + 3 < end; i += 4) { // Use AVX for four doubles\n        __m256d sum = _mm256_set_pd(\n            src[0] / double(Index<modei>(i + 3, 0)),\n            src[0] / double(Index<modei>(i + 2, 0)),\n            src[0] / double(Index<modei>(i + 1, 0)),\n            src[0] / double(Index<modei>(i + 0, 0)));\n\n        __m256d ti = modei?\n            _mm256_set_pd(i + 3, i + 2, i + 1, i) :\n            _mm256_set_pd(i + 4, i + 3, i + 2, i + 1);\n\n        __m256d last = _mm256_set_pd(\n            Index<modei>(i + 3, 0),\n            Index<modei>(i + 2, 0),\n            Index<modei>(i + 1, 0),\n            Index<modei>(i + 0, 0));\n\n        for(int j = 1; j < length; j++) {\n            __m256d idx = last + ti + _mm256_set1_pd(j);\n            last = idx;\n            sum = sum + _mm256_set1_pd(src[j]) / idx;\n        }\n\n        _mm256_storeu_pd(dst + i, sum);\n    }\n    // Handle any remaining elements individually\n    for(; i < end; i++) {\n        double sum = 0;\n        for (int j = 0; j < length; j++)\n            sum += src[j] / double(Index<modei>(i, j));\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp,\n                   int begin, int end, int N) {\n    EvalATimesU (src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\ndouble spectral_game(int N) {\n    __attribute__((aligned(32))) double u[N];\n    __attribute__((aligned(32))) double v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;\n\n        for(int i = begin; i < end; i++)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n\n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        14.526,
        86.862
    ],
    "2": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <vector>\n\n// Precompute as needed, but verify correctness of indices\nint precompute_index(int i, int j, int N, bool modei) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei ? i : j) + 1;\n}\n\nvoid EvalPartCorrected(double *__restrict__ src, double *__restrict__ dst, int begin, int end, int length, bool modei) {\n    for (int i = begin; i < end; i++) {\n        double sum = 0;\n        for (int j = 0; j < length; j++) {\n            sum += src[j] / double(precompute_index(i, j, length, modei));\n        }\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPartCorrected(src, dst, begin, end, N, true);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPartCorrected(src, dst, begin, end, N, false);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp, int begin, int end, int N) {\n    EvalATimesU(src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\n// Spectral game function should return consistent results\n// Keeping structures simple to ensure correctness\n\ndouble spectral_game(int N) {\n    std::vector<double> u(N, 1.0);\n    std::vector<double> v(N, 0.0);\n    std::vector<double> tmp(N, 0.0);\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared)\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount - 1)) ? (begin + chunk) : N;\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u.data(), v.data(), tmp.data(), begin, end, N);\n            EvalAtATimesU(v.data(), u.data(), tmp.data(), begin, end, N);\n        }\n\n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    return std::sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? std::atoi(argv[1]) : 2000);\n    std::printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}\n",
        62.647,
        349.033
    ],
    "3": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <immintrin.h>  // For AVX intrinsics\n\n// Precompute the index with optimization to avoid repeated division\nint precompute_index(int i, int j, int N, bool modei) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei ? i : j) + 1;\n}\n\n// Optimized function with AVX for vectorization\nvoid OptimizedEvalPartCorrected(double *__restrict__ src, double *__restrict__ dst, int begin, int end, int length, bool modei) {\n    for (int i = begin; i < end; i++) {\n        __m256d sum_vec = _mm256_setzero_pd();\n        int j = 0;\n        for (; j <= length - 4; j += 4) {\n            __m256d src_vec = _mm256_loadu_pd(&src[j]);\n            // Precompute indices for the vectorized iteration\n            __m256d indices = _mm256_set_pd(precompute_index(i, j + 3, length, modei),\n                                            precompute_index(i, j + 2, length, modei),\n                                            precompute_index(i, j + 1, length, modei),\n                                            precompute_index(i, j, length, modei));\n            __m256d div_result = _mm256_div_pd(src_vec, indices);\n            sum_vec = _mm256_add_pd(sum_vec, div_result);\n        }\n        // Horizontal sum of a vector sum_vec\n        double sum_array[4];\n        _mm256_storeu_pd(sum_array, sum_vec);\n        double sum = sum_array[0] + sum_array[1] + sum_array[2] + sum_array[3];\n        // Handle remaining elements\n        for (; j < length; j++) {\n            sum += src[j] / double(precompute_index(i, j, length, modei));\n        }\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    OptimizedEvalPartCorrected(src, dst, begin, end, N, true);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    OptimizedEvalPartCorrected(src, dst, begin, end, N, false);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp, int begin, int end, int N) {\n    EvalATimesU(src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\n// Spectral game function should return consistent results\n// Keeping structures simple to ensure correctness\n\ndouble spectral_game(int N) {\n    double u[N] __attribute__((aligned(32))) = {1.0};\n    double v[N] __attribute__((aligned(32))) = {0.0};\n    double tmp[N] __attribute__((aligned(32))) = {0.0};\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared)\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount - 1)) ? (begin + chunk) : N;\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n\n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    return std::sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? std::atoi(argv[1]) : 2000);\n    std::printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        62.366,
        353.169
    ],
    "4": [
        "#include <iostream>\n#include <vector>\n#include <cstddef>  // For std::ptrdiff_t\n#include <cmath>\n#include <cstdio>  // For std::printf\n\n// Function to compute index correctly\nint precompute_index(int i, int j, bool modei) {\n    return (((i + j) * (i + j + 1)) / 2) + (modei ? i : j) + 1; // Adding 1 to avoid 0 index\n}\n\n// Function reverts the original loop behavior\nvoid EvalPartCorrected(double *src, double *dst, int begin, int end, int length, bool modei) {\n    for (int i = begin; i < end; i++) {\n        double sum = 0.0;\n        for (int j = 0; j < length; j++) {\n            int idx = precompute_index(i, j, modei);\n            if (idx == 0) continue; // safeguard, though should never be zero\n            sum += src[j] / static_cast<double>(idx);\n        }\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPartCorrected(src, dst, begin, end, N, true);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPartCorrected(src, dst, begin, end, N, false);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp, int begin, int end, int N) {\n    EvalATimesU(src, tmp, begin, end, N);\n    EvalAtTimesU(tmp, dst, begin, end, N);\n}\n\n// Utilize standard alloc methods for simplicity\ndouble* allocate_and_initialize(size_t size, double init_value) {\n    double* array = new double[size];\n    std::fill(array, array + size, init_value);\n    return array;\n}\n\n// Main function implementing Spectral Game\ndouble spectral_game(int N) {\n    double* u = allocate_and_initialize(N, 1.0);\n    double* v = allocate_and_initialize(N, 0.0);\n    double* tmp = allocate_and_initialize(N, 0.0);\n\n    if (!u || !v || !tmp) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        delete[] u; delete[] v; delete[] tmp;\n        std::exit(EXIT_FAILURE);\n    }\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    int iterations = 10;\n    for (int ite = 0; ite < iterations; ++ite) {\n        EvalAtATimesU(u, v, tmp, 0, N, N);\n        EvalAtATimesU(v, u, tmp, 0, N, N); // Ensure correct reuse of tmp\n    }\n\n    for (int i = 0; i < N; i++) {\n        vv += v[i] * v[i];\n        vBv += u[i] * v[i];\n    }\n\n    delete[] u;\n    delete[] v;\n    delete[] tmp;\n\n    return std::sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? std::atoi(argv[1]) : 2000);\n    std::printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}\n",
        299.477,
        5614.266
    ],
    "5": [
        "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>  // For std::printf\n\n// Function to compute index as per the logic, ensuring correct bounds\nint computeIndex(int i, int j) {\n    return ((i + j) * (i + j + 1)) / 2 + i;\n}\n\n// Optimized function for part of the operation\nvoid EvalPartOptimized(double *src, double *dst, int begin, int end, bool modei) {\n    for (int i = begin; i < end; ++i) {\n        double sum = 0.0;\n        if (modei) {\n            for (int j = 0; j < end; ++j) {\n                sum += src[j] / (1.0 + computeIndex(i, j));\n            }\n        } else {\n            for (int j = 0; j < end; ++j) {\n                sum += src[j] / (1.0 + computeIndex(j, i));\n            }\n        }\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end) {\n    EvalPartOptimized(src, dst, begin, end, true);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end) {\n    EvalPartOptimized(src, dst, begin, end, false);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp, int begin, int end) {\n    EvalATimesU(src, tmp, begin, end);\n    EvalAtTimesU(tmp, dst, begin, end);\n}\n\nstd::vector<double> allocate_and_initialize(size_t size, double init_value) {\n    std::vector<double> array(size, init_value);\n    return array;\n}\n\n// Main function implementing Spectral Norm Calculation\ndouble spectral_game(int N) {\n    std::vector<double> u = allocate_and_initialize(N, 1.0);\n    std::vector<double> v = allocate_and_initialize(N, 0.0);\n    std::vector<double> tmp = allocate_and_initialize(N, 0.0);\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    int iterations = 10;\n    for (int ite = 0; ite < iterations; ++ite) {\n        EvalAtATimesU(u.data(), v.data(), tmp.data(), 0, N);\n        EvalAtATimesU(v.data(), u.data(), tmp.data(), 0, N);\n    }\n\n    for (int i = 0; i < N; i++) {\n        vv += v[i] * v[i];\n        vBv += u[i] * v[i];\n    }\n\n    return std::sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? std::atoi(argv[1]) : 2000);\n    std::printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        342.298,
        6637.224
    ]
}

Program executed for 9.107257 minutes