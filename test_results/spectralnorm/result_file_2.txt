{
    "0": [
        "// The Computer Language Benchmarks Game\n// http://benchmarksgame.alioth.debian.org/\n//\n// Original C contributed by Sebastien Loisel\n// Conversion to C++ by Jon Harrop\n// OpenMP parallelize by The Anh Tran\n// Add SSE by The Anh Tran\n// Additional SSE optimization by Krzysztof Jakubowski\n\n// g++ -pipe -O3 -march=native -fopenmp -mfpmath=sse -msse2 \\\n//     ./spec.c++ -o ./spec.run\n\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <emmintrin.h>\n\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei? i : j) + 1;\n}\n\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst,\n                int begin, int end, int length) {\n    int i = begin;\n\n    for(; i + 1 < end; i += 2) {\n        __m128d sum = _mm_set_pd(\n\t\t\tsrc[0] / double(Index<modei>(i + 1, 0)),\n\t\t\tsrc[0] / double(Index<modei>(i + 0, 0)));\n    \n\t\t__m128d ti = modei?\n\t\t\t_mm_set_pd(i + 1, i + 0) :\n\t\t\t_mm_set_pd(i + 2, i + 1);\t\n\t\t__m128d last = _mm_set_pd(\n\t\t\tIndex<modei>(i + 1, 0),\n\t\t\tIndex<modei>(i + 0, 0));\n\n        for(int j = 1; j < length; j++) {\n\t\t\t__m128d idx = last + ti + _mm_set1_pd(j);\n\t\t\tlast = idx;\n            sum = sum + _mm_set1_pd(src[j]) / idx;\n        }\n\n        _mm_storeu_pd(dst + i + 0, sum);\n    }\n    for(; i < end; i++) {\n        double sum = 0;\n        for (int j = 0; j < length; j++)\n            sum += src[j] / double(Index<modei>(i, j));\n        dst[i] = sum;\n    }\n\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp,\n                   int begin, int end, int N) {\n    EvalATimesU (src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\ndouble spectral_game(int N) {\n    __attribute__((aligned(16))) double u[N];\n    __attribute__((aligned(16))) double v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        // this block will be executed by NUM_THREADS\n        // variable declared in this block is private for each thread\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        // calculate each thread's working range [r1 .. r2) => static schedule\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;\n\n        for(int i = begin; i < end; i++)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n    \n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        31.768,
        178.454
    ],
    "1": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <emmintrin.h>\n\nconstexpr int cache_line_size = 64;\n\n// Ensure alignment for cache-line efficiency\nvoid* aligned_malloc(size_t size) {\n    void* ptr;\n    posix_memalign(&ptr, cache_line_size, size);\n    return ptr;\n}\n\nvoid aligned_free(void* ptr) {\n    free(ptr);\n}\n\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei? i : j) + 1;\n}\n\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst,\n                int begin, int end, int length) {\n    int i = begin;\n\n    for(; i + 1 < end; i += 2) {\n        __m128d sum = _mm_set_pd(\n            src[0] / double(Index<modei>(i + 1, 0)),\n            src[0] / double(Index<modei>(i + 0, 0)));\n        \n        __m128d ti = modei ?\n            _mm_set_pd(i + 1, i + 0) :\n            _mm_set_pd(i + 2, i + 1);\n        __m128d last = _mm_set_pd(\n            Index<modei>(i + 1, 0),\n            Index<modei>(i + 0, 0));\n\n        for(int j = 1; j < length; j++) {\n            __m128d idx = last + ti + _mm_set1_pd(j);\n            last = idx;\n            sum = sum + _mm_set1_pd(src[j]) / idx;\n        }\n\n        _mm_store_pd(dst + i, sum);\n    }\n    for(; i < end; i++) {\n        double sum = 0;\n        for (int j = 0; j < length; j++)\n            sum += src[j] / double(Index<modei>(i, j));\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp,\n                   int begin, int end, int N) {\n    EvalATimesU (src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\ndouble spectral_game(int N) {\n    double* u = (double*)aligned_malloc(N * sizeof(double));\n    double* v = (double*)aligned_malloc(N * sizeof(double));\n    double* tmp = (double*)aligned_malloc(N * sizeof(double));\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;\n\n        for(int i = begin; i < end; i++)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n    \n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    aligned_free(u);\n    aligned_free(v);\n    aligned_free(tmp);\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        31.277,
        175.568
    ],
    "2": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm> // For std::fill_n\n#include <cstddef> // For size_t\n\nstatic inline double eval_A(int i, int j) {\n    return 1.0 / ((i + j) * (i + j + 1) / 2 + i + 1);\n}\n\nvoid multiply_Av(const std::vector<double>& v, std::vector<double>& Av, int N) {\n    for (int i = 0; i < N; ++i) {\n        double sum = 0;\n        for (int j = 0; j < N; ++j) {\n            sum += eval_A(i, j) * v[j];\n        }\n        Av[i] = sum;\n    }\n}\n\nvoid multiply_Atv(const std::vector<double>& v, std::vector<double>& Atv, int N) {\n    for (int i = 0; i < N; ++i) {\n        double sum = 0;\n        for (int j = 0; j < N; ++j) {\n            sum += eval_A(j, i) * v[j];\n        }\n        Atv[i] = sum;\n    }\n}\n\nvoid multiply_AtAv(const std::vector<double>& v, std::vector<double>& AtAv, int N) {\n    std::vector<double> u(N);\n    multiply_Av(v, u, N);\n    multiply_Atv(u, AtAv, N);\n}\n\nint main(int argc, char *argv[]) {\n    int N = (argc >= 2) ? atoi(argv[1]) : 2000;\n    std::vector<double> u(N, 1.0), v(N);\n\n    for (int i = 0; i < 10; ++i) {\n        multiply_AtAv(u, v, N);\n        multiply_AtAv(v, u, N);\n    }\n\n    double vBv = 0.0, vv = 0.0;\n    for (int i = 0; i < N; ++i) {\n        vBv += u[i] * v[i];\n        vv += v[i] * v[i];\n    }\n\n    printf(\"%.9f\\n\", std::sqrt(vBv / vv));\n    return 0;\n}",
        439.315,
        8692.568
    ],
    "3": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm> // For std::fill_n\n#include <cstddef> // For size_t\n#include <omp.h>   // For OpenMP\n\nstatic inline double eval_A(int i, int j) {\n    return 1.0 / ((i + j) * (i + j + 1) / 2 + i + 1);\n}\n\nvoid multiply_Av(const std::vector<double>& v, std::vector<double>& Av, int N) {\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        double sum = 0;\n        for (int j = 0; j < N; ++j) {\n            sum += eval_A(i, j) * v[j];\n        }\n        Av[i] = sum;\n    }\n}\n\nvoid multiply_Atv(const std::vector<double>& v, std::vector<double>& Atv, int N) {\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        double sum = 0;\n        for (int j = 0; j < N; ++j) {\n            sum += eval_A(j, i) * v[j];\n        }\n        Atv[i] = sum;\n    }\n}\n\nvoid multiply_AtAv(const std::vector<double>& v, std::vector<double>& AtAv, int N) {\n    std::vector<double> u(N);  // Pre-allocated\n    multiply_Av(v, u, N);\n    multiply_Atv(u, AtAv, N);\n}\n\nint main(int argc, char *argv[]) {\n    int N = (argc >= 2) ? atoi(argv[1]) : 2000;\n    std::vector<double> u(N, 1.0), v(N);\n\n    for (int i = 0; i < 10; ++i) {\n        multiply_AtAv(u, v, N);\n        multiply_AtAv(v, u, N);\n    }\n\n    double vBv = 0.0, vv = 0.0;\n    for (int i = 0; i < N; ++i) {\n        vBv += u[i] * v[i];\n        vv += v[i] * v[i];\n    }\n\n    printf(\"%.9f\\n\", std::sqrt(vBv / vv));\n    return 0;\n}",
        74.065,
        402.791
    ],
    "4": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <x86intrin.h> // For SSE instructions\n#include <omp.h>\n\nconstexpr int cache_line_size = 64;\n\nvoid* aligned_malloc(size_t size) {\n    void* ptr;\n    posix_memalign(&ptr, cache_line_size, size);\n    return ptr;\n}\n\nvoid aligned_free(void* ptr) {\n    free(ptr);\n}\n\nstatic inline double eval_A(int i, int j) {\n    return 1.0 / ((i + j) * (i + j + 1) / 2 + i + 1);\n}\n\nvoid multiply_Av(const double* __restrict v, double* __restrict Av, int N) {\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        double sum = 0;\n        for (int j = 0; j < N; ++j) {\n            sum += eval_A(i, j) * v[j];\n        }\n        Av[i] = sum;\n    }\n}\n\nvoid multiply_Atv(const double* __restrict v, double* __restrict Atv, int N) {\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        double sum = 0;\n        for (int j = 0; j < N; ++j) {\n            sum += eval_A(j, i) * v[j];\n        }\n        Atv[i] = sum;\n    }\n}\n\nvoid multiply_AtAv(const double* __restrict v, double* __restrict AtAv, int N) {\n    double* u = (double*)aligned_malloc(N * sizeof(double));\n    multiply_Av(v, u, N);\n    multiply_Atv(u, AtAv, N);\n    aligned_free(u);\n}\n\nint main(int argc, char *argv[]) {\n    int N = (argc >= 2) ? atoi(argv[1]) : 2000;\n    \n    double* u = (double*)aligned_malloc(N * sizeof(double));\n    double* v = (double*)aligned_malloc(N * sizeof(double));\n    \n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        u[i] = 1.0;\n    }\n\n    for (int i = 0; i < 10; ++i) {\n        multiply_AtAv(u, v, N);\n        multiply_AtAv(v, u, N);\n    }\n\n    double vBv = 0.0, vv = 0.0;\n    \n    #pragma omp parallel for reduction(+:vBv,vv)\n    for (int i = 0; i < N; ++i) {\n        vBv += u[i] * v[i];\n        vv += v[i] * v[i];\n    }\n\n    printf(\"%.9f\\n\", std::sqrt(vBv / vv));\n\n    aligned_free(u);\n    aligned_free(v);\n\n    return 0;\n}",
        61.913,
        335.218
    ],
    "5": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <x86intrin.h> // For SSE instructions\n#include <omp.h>\n#include <vector>\n\nconstexpr int cache_line_size = 64;\n\ntypedef std::vector<std::vector<double>> Matrix;\n\nvoid* aligned_malloc(size_t size) {\n    void* ptr;\n    posix_memalign(&ptr, cache_line_size, size);\n    return ptr;\n}\n\nvoid aligned_free(void* ptr) {\n    free(ptr);\n}\n\nstatic inline double eval_A(int i, int j, Matrix &cache) {\n    if (cache[i][j] < 0) { // Compute only if not already computed\n        cache[i][j] = 1.0 / ((i + j) * (i + j + 1) / 2 + i + 1);\n    }\n    return cache[i][j];\n}\n\nvoid multiply_Av(const double* __restrict v, double* __restrict Av, int N, Matrix &cache) {\n    #pragma omp parallel for simd\n    for (int i = 0; i < N; ++i) {\n        double sum = 0;\n        for (int j = 0; j < N; ++j) {\n            sum += eval_A(i, j, cache) * v[j];\n        }\n        Av[i] = sum;\n    }\n}\n\nvoid multiply_Atv(const double* __restrict v, double* __restrict Atv, int N, Matrix &cache) {\n    #pragma omp parallel for simd\n    for (int i = 0; i < N; ++i) {\n        double sum = 0;\n        for (int j = 0; j < N; ++j) {\n            sum += eval_A(j, i, cache) * v[j];\n        }\n        Atv[i] = sum;\n    }\n}\n\nvoid multiply_AtAv(const double* __restrict v, double* __restrict AtAv, int N, Matrix &cache) {\n    double* u = (double*)aligned_malloc(N * sizeof(double));\n    multiply_Av(v, u, N, cache);\n    multiply_Atv(u, AtAv, N, cache);\n    aligned_free(u);\n}\n\nint main(int argc, char *argv[]) {\n    int N = (argc >= 2) ? atoi(argv[1]) : 2000;\n    \n    double* u = (double*)aligned_malloc(N * sizeof(double));\n    double* v = (double*)aligned_malloc(N * sizeof(double));\n    \n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        u[i] = 1.0;\n    }\n    \n    // Initialize cache with -1 to signify not computed\n    Matrix cache(N, std::vector<double>(N, -1));\n\n    for (int i = 0; i < 10; ++i) {\n        multiply_AtAv(u, v, N, cache);\n        multiply_AtAv(v, u, N, cache);\n    }\n\n    double vBv = 0.0, vv = 0.0;\n    \n    #pragma omp parallel for reduction(+:vBv,vv)\n    for (int i = 0; i < N; ++i) {\n        vBv += u[i] * v[i];\n        vv += v[i] * v[i];\n    }\n\n    printf(\"%.9f\\n\", std::sqrt(vBv / vv));\n\n    aligned_free(u);\n    aligned_free(v);\n\n    return 0;\n}",
        224.623,
        1381.784
    ]
}

Program executed for 5.814225 minutes