{
    "0": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n\n\nconst size_t    LINE_SIZE = 64;\n\nclass Apr\n{\npublic:\n    Apr() \n    {\n        apr_initialize();\n    }\n\n    ~Apr() \n    {\n        apr_terminate();\n    }\n};\n\nstruct Node \n{\n    Node *l, *r;\n    \n    int check() const \n    {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nclass NodePool\n{\npublic:\n    NodePool() \n    {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() \n    {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc()\n    {\n        return (Node *)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear()\n    {\n        apr_pool_clear(pool);\n    }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode *make(int d, NodePool &store)\n{\n    Node* root = store.alloc();\n\n    if(d>0){\n        root->l=make(d-1, store);\n        root->r=make(d-1, store);\n    }else{\n        root->l=root->r=0;\n    }\n\n    return root;\n}\n\nint main(int argc, char *argv[]) \n{\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2,\n                             (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth+1;\n\n    // Alloc then dealloc stretchdepth tree\n    {\n        NodePool store;\n        Node *c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    // buffer to store output of each thread\n    char *outputstr = (char*)malloc(LINE_SIZE * (max_depth +1) * sizeof(char));\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        // Create a memory pool for this thread to use.\n        NodePool store;\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            Node *a = make(d, store);\n            c += a->check();\n            store.clear();\n        }\n\n        // each thread write to separate location\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    // print all results\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + (d * LINE_SIZE) );\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << (long_lived_tree->check()) << \"\\n\";\n\n    return 0;\n}",
        85.264,
        762.272
    ],
    "1": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n#include <unordered_map>\n\nconst size_t    LINE_SIZE = 64;\n\nclass Apr\n{\npublic:\n    Apr() \n    {\n        apr_initialize();\n    }\n\n    ~Apr() \n    {\n        apr_terminate();\n    }\n};\n\nstruct Node \n{\n    Node *l, *r;\n    \n    int check() const \n    {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nclass NodePool\n{\npublic:\n    NodePool() \n    {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() \n    {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc()\n    {\n        return (Node *)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear()\n    {\n        apr_pool_clear(pool);\n    }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode* make(int d, NodePool& store, std::unordered_map<int, Node*>& memo)\n{\n    if (memo.find(d) != memo.end()) {\n        return memo[d];\n    }\n    \n    Node* root = store.alloc();\n\n    if (d > 0) {\n        root->l = make(d - 1, store, memo);\n        root->r = make(d - 1, store, memo);\n    }\n    else {\n        root->l = root->r = 0;\n    }\n\n    memo[d] = root;\n    return root;\n}\n\nint check_tree(Node* node, std::unordered_map<Node*, int>& check_memo) {\n    if (check_memo.find(node) != check_memo.end()) {\n        return check_memo[node];\n    }\n    int result = node->check();\n    check_memo[node] = result;\n    return result;\n}\n\nint main(int argc, char* argv[]) \n{\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2,\n                             (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    // Alloc then dealloc stretchdepth tree\n    {\n        NodePool store;\n        std::unordered_map<int, Node*> memo;\n        Node* c = make(stretch_depth, store, memo);\n        std::unordered_map<Node*, int> check_memo;\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << check_tree(c, check_memo) << std::endl;\n    }\n\n    NodePool long_lived_store;\n    std::unordered_map<int, Node*> long_lived_memo;\n    Node* long_lived_tree = make(max_depth, long_lived_store, long_lived_memo);\n\n    // buffer to store output of each thread\n    char* outputstr = (char*)malloc(LINE_SIZE * (max_depth + 1) * sizeof(char));\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        // Create a memory pool for this thread to use.\n        NodePool store;\n        std::unordered_map<int, Node*> memo;\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            Node* a = make(d, store, memo);\n            std::unordered_map<Node*, int> check_memo;\n            c += check_tree(a, check_memo);\n            store.clear();\n        }\n\n        // each thread write to separate location\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    // print all results\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + (d * LINE_SIZE));\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << (long_lived_tree->check()) << \"\\n\";\n\n    return 0;\n}",
        64.373,
        954.148
    ],
    "2": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n#include <unordered_map>\n#include <omp.h>\n\nconst size_t LINE_SIZE = 64;\n\nclass Apr {\npublic:\n    Apr() { apr_initialize(); }\n    ~Apr() { apr_terminate(); }\n};\n\nstruct Node {\n    Node *l, *r;\n    int check() const { return l ? l->check() + 1 + r->check() : 1; }\n};\n\nclass NodePool {\npublic:\n    NodePool() { apr_pool_create_unmanaged(&pool); }\n    ~NodePool() { apr_pool_destroy(pool); }\n    Node* alloc() { return (Node*) apr_palloc(pool, sizeof(Node)); }\n    void clear() { apr_pool_clear(pool); }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode* make(int d, NodePool& store, std::unordered_map<int, Node*>& memo) {\n    if (memo.find(d) != memo.end()) return memo[d];\n\n    Node* root = store.alloc();\n    if (d > 0) {\n        root->l = make(d - 1, store, memo);\n        root->r = make(d - 1, store, memo);\n    } else {\n        root->l = root->r = 0;\n    }\n\n    memo[d] = root;\n    return root;\n}\n\nvoid compute_trees(int min_depth, int max_depth, char* outputstr) {\n    #pragma omp parallel for\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n        NodePool store;\n        std::unordered_map<int, Node*> memo;\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node* a = make(d, store, memo);\n            std::unordered_map<Node*, int> check_memo;\n            c += a->check();\n            store.clear();\n        }\n\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n                iterations, d, c);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    // Alloc then dealloc stretchdepth tree\n    {\n        NodePool store;\n        std::unordered_map<int, Node*> memo;\n        Node* c = make(stretch_depth, store, memo);\n        std::unordered_map<Node*, int> check_memo;\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \" \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    std::unordered_map<int, Node*> long_lived_memo;\n    Node* long_lived_tree = make(max_depth, long_lived_store, long_lived_memo);\n\n    // buffer to store output of each thread\n    char* outputstr = (char*) malloc(LINE_SIZE * (max_depth + 1) * sizeof(char));\n    compute_trees(min_depth, max_depth, outputstr);\n\n    // print all results\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + LINE_SIZE * d);\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \" << \"check: \" << long_lived_tree->check() << \"\\n\";\n    return 0;\n}",
        33.765,
        431.244
    ],
    "3": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n#include <unordered_map>\n#include <omp.h>\n\nconst size_t LINE_SIZE = 64;\n\nclass Apr {\npublic:\n    Apr() { apr_initialize(); }\n    ~Apr() { apr_terminate(); }\n};\n\nstruct Node {\n    Node *l, *r;\n    int check() const { return l ? l->check() + 1 + r->check() : 1; }\n};\n\nclass NodePool {\npublic:\n    NodePool() : elementCount(0) { apr_pool_create_unmanaged(&pool); }\n    ~NodePool() { apr_pool_destroy(pool); }\n    Node* alloc() { \n        elementCount++;\n        return (Node*) apr_palloc(pool, sizeof(Node)); \n    }\n    void clear() { \n        apr_pool_clear(pool);\n        elementCount = 0; \n    }\n\n    // New method to indicate if pool is used\n    bool isEmpty() const { return elementCount == 0; }\n\n    void createPool() { if (!pool) apr_pool_create_unmanaged(&pool); }\n\nprivate:\n    apr_pool_t* pool;\n    size_t elementCount; // Added to track allocations.\n};\n\nNode* make(int d, NodePool& store, std::unordered_map<int, Node*>& memo) {\n    if (memo.find(d) != memo.end()) return memo[d];\n\n    Node* root = store.alloc();\n    if (d > 0) {\n        root->l = make(d - 1, store, memo);\n        root->r = make(d - 1, store, memo);\n    } else {\n        root->l = root->r = 0;\n    }\n\n    memo[d] = root;\n    return root;\n}\n\nvoid compute_trees(int min_depth, int max_depth, char* outputstr) {\n    #pragma omp parallel for\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n        NodePool store;\n        std::unordered_map<int, Node*> memo;\n\n        for (int i = 1; i <= iterations; ++i) {\n            if (store.isEmpty()) {\n                store.createPool();\n            }\n            Node* a = make(d, store, memo);\n            c += a->check();\n            if (i != iterations) {\n                store.clear();\n            }\n        }\n\n        snprintf(outputstr + LINE_SIZE * d, LINE_SIZE, \"%d\\t trees of depth %d\\t check: %d\\n\",\n                iterations, d, c);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    {\n        NodePool store;\n        std::unordered_map<int, Node*> memo;\n        Node* c = make(stretch_depth, store, memo);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    std::unordered_map<int, Node*> long_lived_memo;\n    Node* long_lived_tree = make(max_depth, long_lived_store, long_lived_memo);\n\n    char* outputstr = (char*) malloc(LINE_SIZE * (max_depth + 1) * sizeof(char));\n    compute_trees(min_depth, max_depth, outputstr);\n\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + LINE_SIZE * d);\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n    return 0;\n}",
        28.84,
        368.402
    ],
    "4": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n#include <vector>\n#include <omp.h>\n\nconst size_t LINE_SIZE = 64;\n\nclass Apr {\npublic:\n    Apr() { apr_initialize(); }\n    ~Apr() { apr_terminate(); }\n};\n\nstruct Node {\n    Node *l, *r;\n    int check() const { return l ? l->check() + 1 + r->check() : 1; }\n};\n\nclass NodePool {\npublic:\n    NodePool() : elementCount(0) { apr_pool_create_unmanaged(&pool); }\n    ~NodePool() { apr_pool_destroy(pool); }\n    Node* alloc() {\n        elementCount++;\n        return (Node*) apr_palloc(pool, sizeof(Node));\n    }\n    void clear() {\n        apr_pool_clear(pool);\n        elementCount = 0;\n    }\n    bool isEmpty() const { return elementCount == 0; }\n    void createPool() { if (!pool) apr_pool_create_unmanaged(&pool); }\n\nprivate:\n    apr_pool_t* pool;\n    size_t elementCount;\n};\n\nNode* make(int d, NodePool& store, std::vector<Node*>& memo) {\n    if (d < memo.size() && memo[d] != nullptr) return memo[d];\n\n    Node* root = store.alloc();\n    if (d > 0) {\n        root->l = make(d - 1, store, memo);\n        root->r = make(d - 1, store, memo);\n    } else {\n        root->l = root->r = nullptr;\n    }\n\n    if (d >= memo.size()) {\n        memo.resize(d + 1, nullptr);\n    }\n    memo[d] = root;\n    return root;\n}\n\nvoid compute_trees(int min_depth, int max_depth, char* outputstr) {\n    #pragma omp parallel for\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n        NodePool store;\n        std::vector<Node*> memo(max_depth + 1, nullptr);\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node* a = make(d, store, memo);\n            c += a->check();\n            store.clear();\n        }\n\n        snprintf(outputstr + LINE_SIZE * d, LINE_SIZE, \"%d\\t trees of depth %d\\t check: %d\\n\",\n                iterations, d, c);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    {\n        NodePool store;\n        std::vector<Node*> memo(stretch_depth + 1, nullptr);\n        Node* c = make(stretch_depth, store, memo);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    std::vector<Node*> long_lived_memo(max_depth + 1, nullptr);\n    Node* long_lived_tree = make(max_depth, long_lived_store, long_lived_memo);\n\n    char* outputstr = (char*) malloc(LINE_SIZE * (max_depth + 1) * sizeof(char));\n    compute_trees(min_depth, max_depth, outputstr);\n\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + LINE_SIZE * d);\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n    return 0;\n}",
        20.008,
        187.362
    ],
    "5": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n#include <vector>\n#include <omp.h>\n\nconst size_t LINE_SIZE = 64;\n\nclass Apr {\npublic:\n    Apr() { apr_initialize(); }\n    ~Apr() { apr_terminate(); }\n};\n\nstruct Node {\n    Node *l, *r;\n    int check() const { return l ? l->check() + 1 + r->check() : 1; }\n};\n\nclass NodePool {\npublic:\n    NodePool() : elementCount(0) { apr_pool_create_unmanaged(&pool); }\n    ~NodePool() { apr_pool_destroy(pool); }\n    Node* alloc() {\n        elementCount++;\n        return (Node*) apr_palloc(pool, sizeof(Node));\n    }\n    void clear() {\n        apr_pool_clear(pool);\n        elementCount = 0;\n    }\n    bool isEmpty() const { return elementCount == 0; }\n    void createPool() { if (!pool) apr_pool_create_unmanaged(&pool); }\n\nprivate:\n    apr_pool_t* pool;\n    size_t elementCount;\n};\n\nNode* make(int d, NodePool& store, std::vector<Node*>& memo) {\n    if (d < memo.size() && memo[d] != nullptr) return memo[d];\n\n    Node* root = store.alloc();\n    if (d > 0) {\n        root->l = make(d - 1, store, memo);\n        root->r = make(d - 1, store, memo);\n    } else {\n        root->l = root->r = nullptr;\n    }\n\n    if (d >= memo.size()) {\n        memo.resize(d + 1, nullptr);\n    }\n    memo[d] = root;\n    return root;\n}\n\nvoid compute_trees(int min_depth, int max_depth, char* outputstr) {\n    #pragma omp parallel for\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n        NodePool store;\n        std::vector<Node*> memo(max_depth + 1, nullptr);\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node* a = make(d, store, memo);\n            c += a->check();\n            store.clear();\n        }\n\n        snprintf(outputstr + LINE_SIZE * d, LINE_SIZE, \"%d\\t trees of depth %d\\t check: %d\\n\",\n                iterations, d, c);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    {\n        NodePool store;\n        std::vector<Node*> memo(stretch_depth + 1, nullptr);\n        Node* c = make(stretch_depth, store, memo);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    std::vector<Node*> long_lived_memo(max_depth + 1, nullptr);\n    Node* long_lived_tree = make(max_depth, long_lived_store, long_lived_memo);\n\n    char* outputstr = (char*) malloc(LINE_SIZE * (max_depth + 1) * sizeof(char));\n    compute_trees(min_depth, max_depth, outputstr);\n\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + LINE_SIZE * d);\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n    return 0;\n}",
        20.258,
        196.128
    ]
}