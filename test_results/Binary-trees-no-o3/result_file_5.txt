{
    "0": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n\n\nconst size_t    LINE_SIZE = 64;\n\nclass Apr\n{\npublic:\n    Apr() \n    {\n        apr_initialize();\n    }\n\n    ~Apr() \n    {\n        apr_terminate();\n    }\n};\n\nstruct Node \n{\n    Node *l, *r;\n    \n    int check() const \n    {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nclass NodePool\n{\npublic:\n    NodePool() \n    {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() \n    {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc()\n    {\n        return (Node *)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear()\n    {\n        apr_pool_clear(pool);\n    }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode *make(int d, NodePool &store)\n{\n    Node* root = store.alloc();\n\n    if(d>0){\n        root->l=make(d-1, store);\n        root->r=make(d-1, store);\n    }else{\n        root->l=root->r=0;\n    }\n\n    return root;\n}\n\nint main(int argc, char *argv[]) \n{\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2,\n                             (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth+1;\n\n    // Alloc then dealloc stretchdepth tree\n    {\n        NodePool store;\n        Node *c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    // buffer to store output of each thread\n    char *outputstr = (char*)malloc(LINE_SIZE * (max_depth +1) * sizeof(char));\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        // Create a memory pool for this thread to use.\n        NodePool store;\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            Node *a = make(d, store);\n            c += a->check();\n            store.clear();\n        }\n\n        // each thread write to separate location\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    // print all results\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + (d * LINE_SIZE) );\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << (long_lived_tree->check()) << \"\\n\";\n\n    return 0;\n}",
        88.071,
        758.063
    ],
    "1": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <memory>\n#include <omp.h>\n\nconst size_t LINE_SIZE = 64;\n\nstruct Node \n{\n    std::unique_ptr<Node> l, r; // using unique_ptr to manage memory automatically\n    \n    int check() const \n    {\n        if (l)\n            return l->check() + 1 + (r ? r->check() : 0);\n        else return 1;\n    }\n};\n\nNode* make(int d)\n{\n    auto root = std::make_unique<Node>();\n\n    if (d > 0) {\n        root->l = std::unique_ptr<Node>(make(d - 1));\n        root->r = std::unique_ptr<Node>(make(d - 1));\n    }\n\n    return root.release();\n}\n\nint main(int argc, char *argv[]) \n{\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2,\n                             (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    // Stretch tree...\n    {\n        auto stretch_tree = std::unique_ptr<Node>(make(stretch_depth));\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << stretch_tree->check() << std::endl;\n    }\n\n    auto long_lived_tree = std::unique_ptr<Node>(make(max_depth));\n\n    char *outputstr = (char*)malloc(LINE_SIZE * (max_depth + 1) * sizeof(char));\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            auto a = std::unique_ptr<Node>(make(d));\n            c += a->check();\n        }\n\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + (d * LINE_SIZE) );\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}",
        2435.334,
        19753.5
    ],
    "2": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <vector>\n#include <omp.h>\n\nconst size_t LINE_SIZE = 64;\n\nstruct Node {\n    Node* l = nullptr;\n    Node* r = nullptr;\n    \n    int check() const \n    {\n        if (l)\n            return l->check() + 1 + (r ? r->check() : 0);\n        else return 1;\n    }\n};\n\nstruct NodePool {\n    std::vector<Node> pool;\n    size_t index = 0;\n\n    Node* alloc() {\n        if (index < pool.size())\n            return &pool[index++];\n        return nullptr;\n    }\n\n    void reset(size_t size) {\n        pool.clear();\n        pool.resize(size);\n        index = 0;\n    }\n};\n\nNode* make(int d, NodePool &pool) {\n    Node* root = pool.alloc();\n    if (!root) return nullptr;\n\n    if (d > 0) {\n        root->l = make(d - 1, pool);\n        root->r = make(d - 1, pool);\n    } else {\n        root->l = root->r = nullptr;\n    }\n\n    return root;\n}\n\nint main(int argc, char *argv[]) \n{\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2,\n                             (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    // Stretch tree...\n    {\n        NodePool stretch_pool;\n        stretch_pool.reset(1U << (stretch_depth+1));\n        Node* stretch_tree = make(stretch_depth, stretch_pool);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << (stretch_tree ? stretch_tree->check() : 0) << std::endl;\n    }\n\n    NodePool long_lived_pool;\n    long_lived_pool.reset(1U << (max_depth+1));\n    Node* long_lived_tree = make(max_depth, long_lived_pool);\n    \n    std::vector<std::string> outputs(max_depth / 2);\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        NodePool thread_pool;\n        thread_pool.reset(iterations * (1U << (d+1)));\n        \n        for (int i = 1; i <= iterations; ++i) \n        {\n            Node* a = make(d, thread_pool);\n            c += (a ? a->check() : 0);\n        }\n\n        char buffer[LINE_SIZE];\n        snprintf(buffer, LINE_SIZE, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n        #pragma omp critical\n        outputs[(d - min_depth) / 2] = buffer;\n    }\n\n    for (const auto& str : outputs)\n        printf(\"%s\", str.c_str());\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << (long_lived_tree ? long_lived_tree->check() : 0) << \"\\n\";\n\n    return 0;\n}",
        214.546,
        1875.698
    ],
    "3": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n#include <vector> // Include vector header\n#include <string> // Include string header for std::string usage\n\nconst size_t LINE_SIZE = 64; // Fixed size for output buffers\n\nclass Apr {\npublic:\n    Apr() { apr_initialize(); }\n    ~Apr() { apr_terminate(); }\n};\n\nstruct Node {\n    Node *l, *r;\n    \n    int check() const {\n        if (l) return l->check() + 1 + r->check();\n        return 1;\n    }\n};\n\nclass NodePool {\npublic:\n    NodePool() { apr_pool_create_unmanaged(&pool); }\n    ~NodePool() { apr_pool_destroy(pool); }\n\n    Node* alloc() { return (Node*)apr_palloc(pool, sizeof(Node)); }\n    void clear() { apr_pool_clear(pool); }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode* make(int d, NodePool &store) {\n    Node* root = store.alloc();\n    if(d > 0) {\n        root->l = make(d - 1, store);\n        root->r = make(d - 1, store);\n    }\n    return root;\n}\n\nint main(int argc, char *argv[]) {\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    {   // Stretch Depth Tree\n        NodePool store;\n        Node *c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    std::vector<std::string> outputs(max_depth / 2);\n\n    #pragma omp parallel for\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        NodePool store;\n        int c = 0;\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node *a = make(d, store);\n            c += a->check();\n            store.clear();\n        }\n        \n        char buffer[LINE_SIZE];\n        snprintf(buffer, LINE_SIZE, \"%d\\t trees of depth %d\\t check: %d\\n\", iterations, d, c);\n\n        #pragma omp critical\n        outputs[(d - min_depth) / 2] = buffer;\n    }\n\n    for (const std::string& str : outputs)\n        std::cout << str;\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}",
        82.001,
        725.994
    ],
    "4": [
        "#include <iostream>\n#include <vector>\n#include <cstdio>   // for snprintf\n\nconst size_t LINE_SIZE = 64;\n\nstruct Node {\n    Node *l, *r;\n\n    Node() : l(nullptr), r(nullptr) {}\n\n    int check() const {\n        if (!l && !r) return 1;\n        return l->check() + 1 + r->check();\n    }\n};\n\nclass NodePool {\n    std::vector<Node*> pool;\n    \npublic:\n    ~NodePool() {\n        clear();\n    }\n\n    Node* alloc() {\n        Node* node = new Node();\n        pool.push_back(node);\n        return node;\n    }\n\n    void clear() {\n        for (Node* node : pool) {\n            delete node;\n        }\n        pool.clear();\n    }\n};\n\nNode* make(int d, NodePool& store) {\n    Node* root = store.alloc();\n    if (d > 0) {\n        root->l = make(d - 1, store);\n        root->r = make(d - 1, store);\n    }\n    return root;\n}\n\nint main(int argc, char* argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    {\n        NodePool store;\n        Node* c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node* long_lived_tree = make(max_depth, long_lived_store);\n\n    std::vector<std::string> outputs((max_depth - min_depth) / 2 + 1);\n\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        NodePool store;\n        int c = 0;\n\n        for (int i = 0; i < iterations; ++i) {\n            Node* a = make(d, store);\n            c += a->check();\n            store.clear();\n        }\n\n        char buffer[LINE_SIZE];\n        snprintf(buffer, LINE_SIZE, \"%d\\t trees of depth %d\\t check: %d\\n\", iterations, d, c);\n        \n        outputs[(d - min_depth) / 2] = buffer;\n    }\n\n    for (const std::string& str : outputs)\n        std::cout << str;\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}",
        1194.508,
        20961.06
    ],
    "5": [
        "#include <iostream>\n#include <vector>\n#include <memory>\n#include <cstddef>\n#include <cstdlib>\n#include <cstdio>\n\nusing namespace std;\n\n// Use a constant for buffer size when needed\nconst size_t LINE_SIZE = 64;\n\n// Node structure for tree construction\nstruct Node {\n    Node* l = nullptr;\n    Node* r = nullptr;\n\n    int check() const {\n        if (!l && !r) return 1;\n        return l->check() + 1 + r->check();\n    }\n};\n\n// Custom Node Pool to allocate nodes and manage them\nclass NodePool {\n    std::vector<std::unique_ptr<Node>> pool;  // Using unique_ptr for RAII\n\npublic:\n    // Allocate a node and keep ownership within pool\n    Node* alloc() {\n        pool.emplace_back(std::make_unique<Node>());\n        return pool.back().get();\n    }\n\n    // Explicitly clear the pool\n    void clear() {\n        pool.clear();\n    }\n};\n\n// Recursively create tree nodes of specified depth\nNode* make(int d, NodePool& store) {\n    Node* root = store.alloc();\n    if (d > 0) {\n        root->l = make(d - 1, store);\n        root->r = make(d - 1, store);\n    }\n    return root;\n}\n\n// Main execution begins here\nint main(int argc, char* argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    // Stretching tree of depth max_depth + 1\n    {\n        NodePool store;\n        Node* c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t check: \" << c->check() << std::endl;\n    }\n\n    // Permanent tree intended to exist through program life\n    NodePool long_lived_store;\n    Node* long_lived_tree = make(max_depth, long_lived_store);\n\n    // Output storage prepared\n    std::vector<std::string> outputs((max_depth - min_depth) / 2 + 1);\n\n    // Process all required tree depths\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        NodePool store;  // Store for creating tree\n        int c = 0;\n\n        for (int i = 0; i < iterations; ++i) {\n            Node* a = make(d, store);\n            c += a->check();\n            // Clearing pool to free memory just for this iteration\n            store.clear();\n        }\n\n        // Preparing result strings safely\n        char buffer[LINE_SIZE];\n        snprintf(buffer, LINE_SIZE, \"%d\\t trees of depth %d\\t check: %d\\n\", iterations, d, c);\n        outputs[(d - min_depth) / 2] = buffer;\n    }\n\n    // Offering printout for accumulated results\n    for (const std::string& str : outputs) {\n        std::cout << str;\n    }\n\n    // Final output for persistently living tree\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}\n",
        3641.293,
        66901.92
    ]
}