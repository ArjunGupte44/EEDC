{
    "0": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n\n\nconst size_t    LINE_SIZE = 64;\n\nclass Apr\n{\npublic:\n    Apr() \n    {\n        apr_initialize();\n    }\n\n    ~Apr() \n    {\n        apr_terminate();\n    }\n};\n\nstruct Node \n{\n    Node *l, *r;\n    \n    int check() const \n    {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nclass NodePool\n{\npublic:\n    NodePool() \n    {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() \n    {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc()\n    {\n        return (Node *)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear()\n    {\n        apr_pool_clear(pool);\n    }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode *make(int d, NodePool &store)\n{\n    Node* root = store.alloc();\n\n    if(d>0){\n        root->l=make(d-1, store);\n        root->r=make(d-1, store);\n    }else{\n        root->l=root->r=0;\n    }\n\n    return root;\n}\n\nint main(int argc, char *argv[]) \n{\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2,\n                             (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth+1;\n\n    // Alloc then dealloc stretchdepth tree\n    {\n        NodePool store;\n        Node *c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    // buffer to store output of each thread\n    char *outputstr = (char*)malloc(LINE_SIZE * (max_depth +1) * sizeof(char));\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        // Create a memory pool for this thread to use.\n        NodePool store;\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            Node *a = make(d, store);\n            c += a->check();\n            store.clear();\n        }\n\n        // each thread write to separate location\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    // print all results\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + (d * LINE_SIZE) );\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << (long_lived_tree->check()) << \"\\n\";\n\n    return 0;\n}",
        85.821,
        771.814
    ],
    "1": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n#include <omp.h>\n#include <stack> // Including the required stack library\n\nconst size_t LINE_SIZE = 64;\n\nclass Apr\n{\npublic:\n    Apr() \n    {\n        apr_initialize();\n    }\n\n    ~Apr() \n    {\n        apr_terminate();\n    }\n};\n\nstruct Node \n{\n    Node *l, *r;\n    \n    int check() const \n    {\n        // Using an iterative solution to reduce recursion depth\n        const Node* current = this;\n        int total = 0;\n        std::stack<const Node*> nodeStack; // Corrected the variable name to avoid conflicts\n        nodeStack.push(current);  // Correct usage of stack\n        while (!nodeStack.empty()) {\n            current = nodeStack.top();\n            nodeStack.pop();\n            total += 1;\n            if (current->l) nodeStack.push(current->l);\n            if (current->r) nodeStack.push(current->r);\n        }\n        return total;\n    }\n};\n\nclass NodePool\n{\npublic:\n    NodePool(int max_nodes) : index(0)\n    {\n        apr_pool_create_unmanaged(&pool);\n        nodes = (Node*) apr_palloc(pool, sizeof(Node) * max_nodes);\n    }\n\n    ~NodePool() \n    {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc()\n    {\n        return &nodes[index++];\n    }\n\n    void clear()\n    {\n        index = 0;\n    }\n\nprivate:\n    apr_pool_t* pool;\n    Node* nodes;\n    int index;\n};\n\nNode *make(int d, NodePool &store)\n{\n    Node* root = store.alloc();\n\n    if(d>0){\n        root->l=make(d-1, store);\n        root->r=make(d-1, store);\n    }else{\n        root->l=root->r=0;\n    }\n\n    return root;\n}\n\nint main(int argc, char *argv[]) \n{\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2,\n                             (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth+1;\n\n    // Alloc then dealloc stretchdepth tree\n    {\n        NodePool store(1 << (stretch_depth + 1)); // Allocate enough nodes for the stretch depth\n        Node *c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store(1 << (max_depth + 1));\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    // buffer to store output of each thread\n    char *outputstr = (char*)malloc(LINE_SIZE * (max_depth +1) * sizeof(char));\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        // Create a memory pool for this thread to use.\n        NodePool store(1 << (d + 1)); // Allocate enough nodes for max depth\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            Node *a = make(d, store);\n            c += a->check();\n            store.clear();\n        }\n\n        // each thread writes to separate location\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    // print all results\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + (d * LINE_SIZE) );\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << (long_lived_tree->check()) << \"\\n\";\n\n    return 0;\n}",
        409.792,
        3344.194
    ],
    "2": [
        "#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <algorithm>\n#include <cstddef>  // For std::size_t and std::ptrdiff_t\n\nusing namespace std;\n\nstruct Node {\n    Node* l;\n    Node* r;\n    int check() const {\n        int total = 0;\n        std::stack<const Node*> stack;\n        stack.push(this);\n        while (!stack.empty()) {\n            const Node* current = stack.top();\n            stack.pop();\n            ++total;\n            if (current->r) stack.push(current->r);\n            if (current->l) stack.push(current->l);\n        }\n        return total;\n    }\n};\n\nclass NodePool {\npublic:\n    NodePool(size_t max_nodes) : nodes(max_nodes), index(0) {}\n    Node* alloc() {\n        return &nodes[index++];\n    }\n    void clear() { index = 0; }\nprivate:\n    std::vector<Node> nodes;\n    size_t index;\n};\n\nNode* make(int depth, NodePool& pool) {\n    Node* node = pool.alloc();\n    if (depth > 0) {\n        node->l = make(depth - 1, pool);\n        node->r = make(depth - 1, pool);\n    } else {\n        node->l = node->r = nullptr;\n    }\n    return node;\n}\n\nint main(int argc, char* argv[]) {\n    int minDepth = 4;\n    int maxDepth = std::max(minDepth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretchDepth = maxDepth + 1;\n\n    {\n        NodePool pool(1 << (stretchDepth + 1));\n        Node* temp = make(stretchDepth, pool);\n        std::cout << \"stretch tree of depth \" << stretchDepth << \"\\t check: \" << temp->check() << \"\\n\";\n    }\n\n    NodePool main_pool(1 << (maxDepth + 1));\n    Node* long_lived_tree = make(maxDepth, main_pool);\n\n    std::vector<std::string> results((maxDepth - minDepth) / 2 + 1);\n\n    for (int depth = minDepth; depth <= maxDepth; depth += 2) {\n        int iterations = 1 << (maxDepth - depth + minDepth);\n        int checksum = 0;\n\n        NodePool pool(1 << (depth + 1));\n        for (int i = 0; i < iterations; ++i) {\n            Node* tree = make(depth, pool);\n            checksum += tree->check();\n            pool.clear();\n        }\n\n        results[(depth - minDepth) / 2] = std::to_string(iterations) + \"\\t trees of depth \" +\n                                          std::to_string(depth) + \"\\t check: \" + std::to_string(checksum) + \"\\n\";\n    }\n\n    for (const auto& result : results)\n        std::cout << result;\n    \n    std::cout << \"long lived tree of depth \" << maxDepth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}",
        1125.343,
        20716.66
    ],
    "3": [
        "#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <algorithm>\n#include <sstream>  // Include for std::ostringstream\n#include <cstddef>  // For std::size_t and std::ptrdiff_t\n#include <omp.h>    // For OpenMP-based parallel processing\n\nusing namespace std;\n\nstruct Node {\n    Node* l;\n    Node* r;\n    int check() const {\n        int total = 0;\n        std::stack<const Node*> stack;\n        stack.push(this);\n        while (!stack.empty()) {\n            const Node* current = stack.top();\n            stack.pop();\n            ++total;\n            if (current->r) stack.push(current->r);\n            if (current->l) stack.push(current->l);\n        }\n        return total;\n    }\n};\n\nclass NodePool {\npublic:\n    NodePool(size_t max_nodes) : nodes(max_nodes), index(0) {}\n    Node* alloc() {\n        return &nodes[index++];\n    }\n    void clear() { index = 0; }\nprivate:\n    std::vector<Node> nodes;\n    size_t index;\n};\n\nNode* make(int depth, NodePool& pool) {\n    Node* node = pool.alloc();\n    if (depth > 0) {\n        node->l = make(depth - 1, pool);\n        node->r = make(depth - 1, pool);\n    } else {\n        node->l = node->r = nullptr;\n    }\n    return node;\n}\n\nint main(int argc, char* argv[]) {\n    int minDepth = 4;\n    int maxDepth = std::max(minDepth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretchDepth = maxDepth + 1;\n\n    {\n        NodePool pool(1 << (stretchDepth + 1));\n        Node* temp = make(stretchDepth, pool);\n        std::cout << \"stretch tree of depth \" << stretchDepth << \"\\t check: \" << temp->check() << \"\\n\";\n    }\n\n    NodePool main_pool(1 << (maxDepth + 1));\n    Node* long_lived_tree = make(maxDepth, main_pool);\n\n    std::vector<std::string> results((maxDepth - minDepth) / 2 + 1);\n\n    #pragma omp parallel for\n    for (int depth = minDepth; depth <= maxDepth; depth += 2) {\n        int iterations = 1 << (maxDepth - depth + minDepth);\n        int checksum = 0;\n\n        NodePool pool(1 << (depth + 1));\n        for (int i = 0; i < iterations; ++i) {\n            Node* tree = make(depth, pool);\n            checksum += tree->check();\n            pool.clear();\n        }\n\n        std::ostringstream oss;\n        oss << iterations << \"\\t trees of depth \" << depth << \"\\t check: \" << checksum << \"\\n\";\n\n        #pragma omp critical\n        {\n            results[(depth - minDepth) / 2] = oss.str();\n        }\n    }\n\n    for (const auto& result : results)\n        std::cout << result;\n    \n    std::cout << \"long lived tree of depth \" << maxDepth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}\n",
        412.296,
        3288.798
    ],
    "4": [
        "#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <cstddef>\n#include <omp.h>\n\nusing namespace std;\n\nstruct Node {\n    Node* l;\n    Node* r;\n    int check() const {\n        int total = 0;\n        std::stack<const Node*> stack;\n        stack.push(this);\n        while (!stack.empty()) {\n            const Node* current = stack.top();\n            stack.pop();\n            ++total;\n            if (current->r) stack.push(current->r);\n            if (current->l) stack.push(current->l);\n        }\n        return total;\n    }\n};\n\nclass NodePool {\npublic:\n    NodePool(size_t max_nodes) : nodes(max_nodes), index(0) {}\n    Node* alloc() {\n        if (index < nodes.size())\n            return &nodes[index++];\n        else\n            return nullptr; // Pool exhaustion handling could go here\n    }\n    void clear() { index = 0; }\nprivate:\n    std::vector<Node> nodes;\n    size_t index;\n};\n\nNode* make_iterative(int depth, NodePool& pool) {\n    std::stack<std::pair<Node*, int>> stack;\n    Node* root = pool.alloc();\n    if (root == nullptr) return nullptr;\n    stack.push({root, depth});\n\n    while (!stack.empty()) {\n        auto [node, d] = stack.top();\n        stack.pop();\n\n        if (d > 0) {\n            node->l = pool.alloc();\n            node->r = pool.alloc();\n            if (node->l != nullptr) stack.push({node->l, d-1});\n            if (node->r != nullptr) stack.push({node->r, d-1});\n        } else {\n            node->l = node->r = nullptr;\n        }\n    }\n    return root;\n}\n\nint main(int argc, char* argv[]) {\n    int minDepth = 4;\n    int maxDepth = std::max(minDepth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretchDepth = maxDepth + 1;\n\n    {\n        NodePool pool(1 << (stretchDepth + 1));\n        Node* temp = make_iterative(stretchDepth, pool);\n        if (temp != nullptr)\n            std::cout << \"stretch tree of depth \" << stretchDepth << \"\\t check: \" << temp->check() << \"\\n\";\n    }\n\n    NodePool main_pool(1 << (maxDepth + 1));\n    Node* long_lived_tree = make_iterative(maxDepth, main_pool);\n\n    std::vector<std::string> results((maxDepth - minDepth) / 2 + 1);\n\n    #pragma omp parallel for\n    for (int depth = minDepth; depth <= maxDepth; depth += 2) {\n        int iterations = 1 << (maxDepth - depth + minDepth);\n        int checksum = 0;\n\n        NodePool pool(1 << (depth + 1));\n        for (int i = 0; i < iterations; ++i) {\n            Node* tree = make_iterative(depth, pool);\n            if (tree != nullptr)\n                checksum += tree->check();\n            pool.clear();\n        }\n\n        std::ostringstream oss;\n        oss << iterations << \"\\t trees of depth \" << depth << \"\\t check: \" << checksum << \"\\n\";\n\n        #pragma omp critical\n        {\n            results[(depth - minDepth) / 2] = oss.str();\n        }\n    }\n\n    for (const auto& result : results)\n        std::cout << result;\n\n    std::cout << \"long lived tree of depth \" << maxDepth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}",
        1055.874,
        8023.204
    ],
    "5": [
        "#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <cstddef>\n#include <mutex>  // for std::mutex\n#include <omp.h>\n\nusing namespace std;\n\nstruct Node {\n    Node* l;\n    Node* r;\n    int check() const {\n        int total = 0;\n        std::stack<const Node*> stack;\n        stack.push(this);\n        while (!stack.empty()) {\n            const Node* current = stack.top();\n            stack.pop();\n            ++total;\n            if (current->r) stack.push(current->r);\n            if (current->l) stack.push(current->l);\n        }\n        return total;\n    }\n};\n\nclass NodePool {\npublic:\n    NodePool(size_t max_nodes) : nodes(max_nodes), index(0) {}\n    Node* alloc() {\n        if (index < nodes.size())\n            return &nodes[index++];\n        else\n            return nullptr; // Handle pool exhaustion\n    }\n    void clear() { index = 0; }\nprivate:\n    std::vector<Node> nodes;\n    size_t index;\n};\n\nNode* make_iterative(int depth, NodePool& pool) {\n    std::stack<std::pair<Node*, int>> stack;\n    Node* root = pool.alloc();\n    if (root == nullptr) return nullptr;\n    stack.push({root, depth});\n\n    while (!stack.empty()) {\n        auto [node, d] = stack.top();\n        stack.pop();\n\n        if (d > 0) {\n            node->l = pool.alloc();\n            node->r = pool.alloc();\n            if (node->l != nullptr) stack.push({node->l, d-1});\n            if (node->r != nullptr) stack.push({node->r, d-1});\n        } else {\n            node->l = node->r = nullptr;\n        }\n    }\n    return root;\n}\n\nint main(int argc, char* argv[]) {\n    int minDepth = 4;\n    int maxDepth = std::max(minDepth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretchDepth = maxDepth + 1;\n\n    {\n        NodePool pool(1 << (stretchDepth + 1));\n        Node* temp = make_iterative(stretchDepth, pool);\n        if (temp != nullptr)\n            std::cout << \"stretch tree of depth \" << stretchDepth << \"\\t check: \" << temp->check() << \"\\n\";\n    }\n\n    NodePool main_pool(1 << (maxDepth + 1));\n    Node* long_lived_tree = make_iterative(maxDepth, main_pool);\n\n    std::vector<std::string> results((maxDepth - minDepth) / 2 + 1);\n\n    // Mutex for critical section\n    std::mutex mutex;\n\n    #pragma omp parallel for\n    for (int depth = minDepth; depth <= maxDepth; depth += 2) {\n        int iterations = 1 << (maxDepth - depth + minDepth);\n        int checksum = 0;\n\n        NodePool pool(1 << (depth + 1));\n        for (int i = 0; i < iterations; ++i) {\n            Node* tree = make_iterative(depth, pool);\n            if (tree != nullptr)\n                checksum += tree->check();\n            pool.clear();\n        }\n\n        std::ostringstream oss;\n        oss << iterations << \"\\t trees of depth \" << depth << \"\\t check: \" << checksum << \"\\n\";\n\n        {\n            std::lock_guard<std::mutex> guard(mutex);\n            results[(depth - minDepth) / 2] = oss.str();\n        }\n    }\n\n    for (const auto& result : results)\n        std::cout << result;\n\n    std::cout << \"long lived tree of depth \" << maxDepth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}",
        1041.479,
        7989.304
    ]
}