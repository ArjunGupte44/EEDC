{
    "0": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n\n\nconst size_t    LINE_SIZE = 64;\n\nclass Apr\n{\npublic:\n    Apr() \n    {\n        apr_initialize();\n    }\n\n    ~Apr() \n    {\n        apr_terminate();\n    }\n};\n\nstruct Node \n{\n    Node *l, *r;\n    \n    int check() const \n    {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nclass NodePool\n{\npublic:\n    NodePool() \n    {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() \n    {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc()\n    {\n        return (Node *)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear()\n    {\n        apr_pool_clear(pool);\n    }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode *make(int d, NodePool &store)\n{\n    Node* root = store.alloc();\n\n    if(d>0){\n        root->l=make(d-1, store);\n        root->r=make(d-1, store);\n    }else{\n        root->l=root->r=0;\n    }\n\n    return root;\n}\n\nint main(int argc, char *argv[]) \n{\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2,\n                             (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth+1;\n\n    // Alloc then dealloc stretchdepth tree\n    {\n        NodePool store;\n        Node *c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    // buffer to store output of each thread\n    char *outputstr = (char*)malloc(LINE_SIZE * (max_depth +1) * sizeof(char));\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        // Create a memory pool for this thread to use.\n        NodePool store;\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            Node *a = make(d, store);\n            c += a->check();\n            store.clear();\n        }\n\n        // each thread write to separate location\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    // print all results\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + (d * LINE_SIZE) );\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << (long_lived_tree->check()) << \"\\n\";\n\n    return 0;\n}",
        51.217,
        541.458
    ],
    "1": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n#include <omp.h>\n\nconst size_t LINE_SIZE = 64;\n\nclass Apr\n{\npublic:\n    Apr() \n    {\n        apr_initialize();\n    }\n\n    ~Apr() \n    {\n        apr_terminate();\n    }\n};\n\nstruct Node \n{\n    Node *l, *r;\n    \n    int check() const \n    {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nclass NodePool\n{\npublic:\n    NodePool()\n    {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool()\n    {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc()\n    {\n        return (Node *)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear()\n    {\n        apr_pool_clear(pool);\n    }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode* make(int d, NodePool &store)\n{\n    Node *root = store.alloc();\n    \n    if(d > 0){\n        root->l = make(d-1, store);\n        root->r = make(d-1, store);\n    } else {\n        root->l = root->r = nullptr;\n    }\n\n    return root;\n}\n\nint main(int argc, char *argv[]) \n{\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2,\n                             (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth+1;\n\n    {\n        NodePool store;\n        Node *c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    char *outputstr = (char*)malloc(LINE_SIZE * (max_depth +1) * sizeof(char));\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        NodePool store;\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            Node *a = make(d, store);\n            c += a->check();\n            store.clear();\n        }\n\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + (d * LINE_SIZE) );\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << (long_lived_tree->check()) << \"\\n\";\n\n    return 0;\n}",
        51.075,
        532.498
    ],
    "2": [
        "#include <iostream>\n#include <memory>\n#include <vector>\n#include <omp.h>\n\nconst size_t LINE_SIZE = 64;\n\nstruct Node \n{\n    std::unique_ptr<Node> l, r;\n    \n    int check() const \n    {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nusing NodeVector = std::vector<std::unique_ptr<Node>>;\n\nstd::unique_ptr<Node> make(int d)\n{\n    auto root = std::make_unique<Node>();\n    if(d > 0){\n        root->l = make(d-1);\n        root->r = make(d-1);\n    }\n    return root;\n}\n\nint main(int argc, char *argv[]) \n{\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    // Stretch tree\nauto stretch_tree = make(stretch_depth);\n    std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n              << \"check: \" << stretch_tree->check() << std::endl;\n\n    // Long-lived tree\n    auto long_lived_tree = make(max_depth);\n\n    char *outputstr = (char*)malloc(LINE_SIZE * (max_depth +1) * sizeof(char));\n\n    #pragma omp parallel for schedule(static)\n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            auto a = make(d);\n            c += a->check();\n        }\n\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + (d * LINE_SIZE) );\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}",
        383.879,
        3667.62
    ],
    "3": [
        "#include <iostream>\n#include <vector>\n#include <omp.h>\n#include <cstdio>\n\nconst size_t LINE_SIZE = 64;\n\nstruct Node {\n    Node* l = nullptr;\n    Node* r = nullptr;\n\n    int check() const {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nNode* make(int d) {\n    Node* root = new Node();\n    if (d > 0) {\n        root->l = make(d-1);\n        root->r = make(d-1);\n    }\n    return root;\n}\n\nvoid deleteTree(Node* node) {\n    if (!node) return;\n    deleteTree(node->l);\n    deleteTree(node->r);\n    delete node;\n}\n\nint main(int argc, char *argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 12));\n    int stretch_depth = max_depth + 1;\n\n    // Stretch tree\n    Node* stretch_tree = make(stretch_depth);\n    std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n              << \"check: \" << stretch_tree->check() << std::endl;\n    deleteTree(stretch_tree);\n\n    // Long-lived tree\n    Node* long_lived_tree = make(max_depth);\n\n    char *outputstr = new char[LINE_SIZE * (max_depth +1)];\n\n    #pragma omp parallel for schedule(dynamic)\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node* a = make(d);\n            c += a->check();\n            deleteTree(a); // Clean up memory after each iteration\n        }\n\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    for (int d = min_depth; d <= max_depth; d += 2)\n        printf(\"%s\", outputstr + (d * LINE_SIZE));\n    delete[] outputstr;\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << long_lived_tree->check() << \"\\n\";\n    deleteTree(long_lived_tree);\n\n    return 0;\n}",
        386.967,
        4110.294
    ],
    "4": [
        "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <mutex>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>  // This line was added to include strlen\n\nconst size_t LINE_SIZE = 128;  // Fixed size for strings\n\nstruct Node {\n    Node* l = nullptr;\n    Node* r = nullptr;\n\n    int check() const {\n        if (l)\n            return l->check() + 1 + (r ? r->check() : 0);\n        else return 1;  // Count current node\n    }\n};\n\n// Thread-safe memory pool\nstruct NodePool {\n    std::vector<Node*> pool;\n    std::mutex mtx;\n\n    Node* allocate() {\n        std::lock_guard<std::mutex> lock(mtx);\n        if (!pool.empty()) {\n            Node* n = pool.back();\n            pool.pop_back();\n            n->l = nullptr;\n            n->r = nullptr;\n            return n;\n        }\n        return new Node();\n    }\n\n    void deallocate(Node* n) {\n        std::lock_guard<std::mutex> lock(mtx);\n        pool.push_back(n);\n    }\n\n    ~NodePool() {\n        for (Node* n : pool) {\n            delete n;\n        }\n    }\n};\n\nNode* make(NodePool& pool, int depth) {\n    Node* root = pool.allocate();\n    if (depth > 0) {\n        root->l = make(pool, depth - 1);\n        root->r = make(pool, depth - 1);\n    }\n    return root;\n}\n\nvoid deleteTree(NodePool& pool, Node* node) {\n    if (!node) return;\n    deleteTree(pool, node->l);\n    deleteTree(pool, node->r);\n    pool.deallocate(node);\n}\n\nint main(int argc, char *argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 12));\n    int stretch_depth = max_depth + 1;\n\n    NodePool pool;\n\n    // Stretch tree\n    Node* stretch_tree = make(pool, stretch_depth);\n    std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n              << \"check: \" << stretch_tree->check() << std::endl;\n    deleteTree(pool, stretch_tree);\n\n    // Long-lived tree\n    Node* long_lived_tree = make(pool, max_depth);\n\n    char *outputstr = new char[LINE_SIZE * (max_depth+1)];  // Allocate buffer safely\n    outputstr[0] = '\\0';  // Initialize with empty string\n\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node* a = make(pool, d);\n            c += a->check();\n            deleteTree(pool, a); // Free memory properly\n        }\n\n        sprintf(outputstr + strlen(outputstr), \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);  // Can safely output to shared\n    }\n\n    printf(\"%s\", outputstr);\n    delete[] outputstr;\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << long_lived_tree->check() << \"\\n\";\n    deleteTree(pool, long_lived_tree);\n\n    return 0;\n}",
        596.905,
        10856.18
    ],
    "5": [
        "#include <iostream>\n#include <vector>\n#include <mutex>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n// Removed OpenMP for debugging output differences\n\nconst size_t LINE_SIZE = 128;\n\nstruct Node {\n    Node* l = nullptr;\n    Node* r = nullptr;\n\n    int check() const {\n        return (l ? l->check() : 0) + (r ? r->check() : 0) + 1;\n    }\n};\n\nclass NodePool {\npublic:\n    std::vector<Node*> pool;\n\n    Node* allocate() {\n        if (!pool.empty()) {\n            Node* n = pool.back();\n            pool.pop_back();\n            n->l = nullptr;\n            n->r = nullptr;\n            return n;\n        }\n        return new Node();\n    }\n\n    void deallocate(Node* n) {\n        pool.push_back(n);\n    }\n\n    ~NodePool() {\n        for (Node* n : pool) {\n            delete n;\n        }\n    }\n};\n\nNode* make(NodePool& pool, int depth) {\n    Node* root = pool.allocate();\n    if (depth > 0) {\n        root->l = make(pool, depth - 1);\n        root->r = make(pool, depth - 1);\n    }\n    return root;\n}\n\nvoid deleteTree(NodePool& pool, Node* node) {\n    if (!node) return;\n    deleteTree(pool, node->l);\n    deleteTree(pool, node->r);\n    pool.deallocate(node);\n}\n\nint main(int argc, char* argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 12));\n    int stretch_depth = max_depth + 1;\n\n    NodePool pool;\n\n    // Stretch tree\n    Node* stretch_tree = make(pool, stretch_depth);\n    std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t check: \" << stretch_tree->check() << std::endl;\n    deleteTree(pool, stretch_tree);\n\n    // Long-lived tree\n    Node* long_lived_tree = make(pool, max_depth);\n\n    std::vector<std::string> results;\n    // std::mutex results_mutex;  // Mutex for threading, not used here\n\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        NodePool local_pool;  // Each depth level gets its own pool to avoid cross-level issues\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node* a = make(local_pool, d);\n            c += a->check();\n            deleteTree(local_pool, a);\n        }\n\n        char buffer[LINE_SIZE];\n        snprintf(buffer, LINE_SIZE, \"%d\\t trees of depth %d\\t check: %d\\n\", iterations, d, c);\n        results.push_back(std::string(buffer));\n    }\n\n    for (auto& result : results) {\n        std::cout << result;\n    }\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t check: \" << long_lived_tree->check() << \"\\n\";\n    deleteTree(pool, long_lived_tree);\n\n    return 0;\n}\n",
        214.021,
        4086.5
    ]
}