{
    "0": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n\n\nconst size_t    LINE_SIZE = 64;\n\nclass Apr\n{\npublic:\n    Apr() \n    {\n        apr_initialize();\n    }\n\n    ~Apr() \n    {\n        apr_terminate();\n    }\n};\n\nstruct Node \n{\n    Node *l, *r;\n    \n    int check() const \n    {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nclass NodePool\n{\npublic:\n    NodePool() \n    {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() \n    {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc()\n    {\n        return (Node *)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear()\n    {\n        apr_pool_clear(pool);\n    }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode *make(int d, NodePool &store)\n{\n    Node* root = store.alloc();\n\n    if(d>0){\n        root->l=make(d-1, store);\n        root->r=make(d-1, store);\n    }else{\n        root->l=root->r=0;\n    }\n\n    return root;\n}\n\nint main(int argc, char *argv[]) \n{\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2,\n                             (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth+1;\n\n    // Alloc then dealloc stretchdepth tree\n    {\n        NodePool store;\n        Node *c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    // buffer to store output of each thread\n    char *outputstr = (char*)malloc(LINE_SIZE * (max_depth +1) * sizeof(char));\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        // Create a memory pool for this thread to use.\n        NodePool store;\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            Node *a = make(d, store);\n            c += a->check();\n            store.clear();\n        }\n\n        // each thread write to separate location\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    // print all results\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + (d * LINE_SIZE) );\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << (long_lived_tree->check()) << \"\\n\";\n\n    return 0;\n}",
        50.993,
        544.733
    ],
    "1": [
        "#include <iostream>\n#include <omp.h>\n#include <memory>\n#include <vector>\n#include <sstream> // Include the necessary header\n\nstruct Node {\n    std::unique_ptr<Node> l, r;\n    int check() const {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nNode* make_iterative(int d) {\n    struct StackNode {\n        Node* node;\n        int depth;\n    };\n\n    std::vector<std::unique_ptr<Node>> nodeStore;\n    std::vector<StackNode> stack;\n\n    Node* root = new Node();\n    stack.push_back({root, d});\n\n    while (!stack.empty()) {\n        StackNode current = stack.back();\n        stack.pop_back();\n        if (current.depth > 0) {\n            current.node->l = std::make_unique<Node>();\n            current.node->r = std::make_unique<Node>();\n            stack.push_back({current.node->r.get(), current.depth - 1});\n            stack.push_back({current.node->l.get(), current.depth - 1});\n        }\n    }\n    return root;\n}\n\nint main(int argc, char *argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    {   // Stretch tree\n        std::unique_ptr<Node> stretch_tree(make_iterative(stretch_depth));\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \" << \"check: \" << stretch_tree->check() << std::endl;\n    }\n\n    std::unique_ptr<Node> long_lived_tree(make_iterative(max_depth));\n\n    std::vector<std::string> outputs(max_depth / 2 - 1);\n\n    #pragma omp parallel\n    {\n        #pragma omp for schedule(static)\n        for (int d = min_depth; d <= max_depth; d += 2) {\n            int iterations = 1 << (max_depth - d + min_depth);\n            int c = 0;\n\n            for (int i = 1; i <= iterations; ++i) {\n                std::unique_ptr<Node> a(make_iterative(d));\n                c += a->check();\n            }\n\n            std::stringstream ss;\n            ss << iterations << \"\\t trees of depth \" << d << \"\\t check: \" << c << \"\\n\";\n\n            #pragma omp critical\n            {\n                outputs[(d - min_depth) / 2] = ss.str();\n            }\n        }\n    }\n\n    for (const auto& result : outputs) {\n        std::cout << result;\n    }\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \" << \"check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}",
        437.431,
        4154.37
    ],
    "2": [
        "#include <iostream>\n#include <omp.h>\n#include <memory>\n#include <vector>\n#include <sstream>\n#include <stack>\n\nstruct Node {\n    Node* l = nullptr;\n    Node* r = nullptr;\n    int check() const {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nclass NodePool {\npublic:\n    NodePool(size_t pool_size) : pool_size_(pool_size) {\n        pool_ = new Node[pool_size_];\n        free_stack_.reserve(pool_size_);\n        for (size_t i = 0; i < pool_size_; ++i) {\n            free_stack_.push_back(&pool_[i]);\n        }\n    }\n\n    ~NodePool() {\n        delete[] pool_;\n    }\n\n    Node* allocate() {\n        if (free_stack_.empty()) {\n            throw std::bad_alloc();\n        }\n        Node* node = free_stack_.back();\n        free_stack_.pop_back();\n        node->l = node->r = nullptr;\n        return node;\n    }\n\n    void deallocate(Node* node) {\n        free_stack_.push_back(node);\n    }\n\nprivate:\n    size_t pool_size_;\n    Node* pool_;\n    std::vector<Node*> free_stack_;\n};\n\nNode* make_iterative(int d, NodePool& pool) {\n    struct StackNode {\n        Node* node;\n        int depth;\n    };\n\n    std::stack<StackNode> stack;\n\n    Node* root = pool.allocate();\n    stack.push({root, d});\n\n    while (!stack.empty()) {\n        StackNode current = stack.top();\n        stack.pop();\n        if (current.depth > 0) {\n            current.node->l = pool.allocate();\n            current.node->r = pool.allocate();\n            stack.push({current.node->r, current.depth - 1});\n            stack.push({current.node->l, current.depth - 1});\n        }\n    }\n    return root;\n}\n\nvoid free_tree(Node* root, NodePool& pool) {\n    if (root == nullptr) return;\n    free_tree(root->l, pool);\n    free_tree(root->r, pool);\n    pool.deallocate(root);\n}\n\nint main(int argc, char* argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    NodePool pool((1 << (stretch_depth + 1)) - 1);  // Allocate a sufficient pool size\n\n    // Stretch tree\n    Node* stretch_tree = make_iterative(stretch_depth, pool);\n    std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \" << \"check: \" << stretch_tree->check() << std::endl;\n    free_tree(stretch_tree, pool);\n\n    Node* long_lived_tree = make_iterative(max_depth, pool);\n\n    std::vector<std::string> outputs(max_depth / 2 - 1);\n\n    #pragma omp parallel\n    {\n        #pragma omp for schedule(static)\n        for (int d = min_depth; d <= max_depth; d += 2) {\n            int iterations = 1 << (max_depth - d + min_depth);\n            int c = 0;\n\n            for (int i = 1; i <= iterations; ++i) {\n                Node* a = make_iterative(d, pool);\n                c += a->check();\n                free_tree(a, pool);\n            }\n\n            std::stringstream ss;\n            ss << iterations << \"\\t trees of depth \" << d << \"\\t check: \" << c << \"\\n\";\n\n            #pragma omp critical\n            {\n                outputs[(d - min_depth) / 2] = ss.str();\n            }\n        }\n    }\n\n    for (const auto& result : outputs) {\n        std::cout << result;\n    }\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \" << \"check: \" << long_lived_tree->check() << \"\\n\";\n\n    free_tree(long_lived_tree, pool);\n\n    return 0;\n}",
        13.871,
        294.071
    ],
    "3": [
        "#include <iostream>\n#include <memory>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cstdlib>\n#include <sstream> // for std::stringstream\n\n// Define the Node structure\nstruct Node {\n    Node* l = nullptr;\n    Node* r = nullptr;\n    int check() const {\n        if (l)\n            return l->check() + 1 + r->check();\n        else\n            return 1;\n    }\n};\n\n// NodePool class for managing node allocations\nclass NodePool {\npublic:\n    NodePool(size_t pool_size) : pool_size_(pool_size) {\n        pool_ = new Node[pool_size_];\n        free_stack_.reserve(pool_size_);\n        for (size_t i = 0; i < pool_size_; ++i) {\n            free_stack_.push_back(&pool_[i]);\n        }\n    }\n\n    ~NodePool() {\n        delete[] pool_;\n    }\n\n    Node* allocate() {\n        if (free_stack_.empty()) {\n            throw std::bad_alloc();\n        }\n        Node* node = free_stack_.back();\n        free_stack_.pop_back();\n        node->l = node->r = nullptr;\n        return node;\n    }\n\n    void deallocate(Node* node) {\n        free_stack_.push_back(node);\n    }\n\nprivate:\n    size_t pool_size_;\n    Node* pool_;\n    std::vector<Node*> free_stack_;\n};\n\n// Create trees iteratively\nNode* make_iterative(int d, NodePool& pool) {\n    struct StackNode {\n        Node* node;\n        int depth;\n    };\n\n    std::stack<StackNode> stack;\n\n    Node* root = pool.allocate();\n    stack.push({root, d});\n\n    while (!stack.empty()) {\n        StackNode current = stack.top();\n        stack.pop();\n        if (current.depth > 0) {\n            current.node->l = pool.allocate();\n            current.node->r = pool.allocate();\n            stack.push({current.node->r, current.depth - 1});\n            stack.push({current.node->l, current.depth - 1});\n        }\n    }\n    return root;\n}\n\n// Free all nodes in a tree\nvoid free_tree(Node* root, NodePool& pool) {\n    if (root == nullptr) return;\n    free_tree(root->l, pool);\n    free_tree(root->r, pool);\n    pool.deallocate(root);\n}\n\n// Entry point\nint main(int argc, char* argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? std::atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    NodePool pool((1 << (stretch_depth + 1)) - 1);  // Node pool\n\n    // Create and free a stretch tree\n    Node* stretch_tree = make_iterative(stretch_depth, pool);\n    std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \" << \"check: \" << stretch_tree->check() << std::endl;\n    free_tree(stretch_tree, pool);\n\n    // Long-lived tree\n    Node* long_lived_tree = make_iterative(max_depth, pool);\n\n    // Construct output\n    std::vector<std::string> outputs((max_depth / 2) - 1);\n\n    #pragma omp parallel\n    {\n        #pragma omp for\n        for (int d = min_depth; d <= max_depth; d += 2) {\n            int iterations = 1 << (max_depth - d + min_depth);\n            int c = 0;  // local check counter\n\n            for (int i = 1; i <= iterations; ++i) {\n                Node* a = make_iterative(d, pool);\n                c += a->check();\n                free_tree(a, pool);\n            }\n\n            std::stringstream ss;\n            ss << iterations << \"\\t trees of depth \" << d << \"\\t check: \" << c << \"\\n\";\n\n            #pragma omp critical\n            {\n                outputs[(d - min_depth) / 2] = ss.str();\n            }\n        }\n    }\n\n    for (const auto& result : outputs) {\n        std::cout << result;\n    }\n\n    // Long-lived tree check\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \" << \"check: \" << long_lived_tree->check() << \"\\n\";\n\n    free_tree(long_lived_tree, pool);\n\n    return 0;\n}",
        14.11,
        321.24
    ],
    "4": [
        "#include <iostream>\n#include <memory>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cstdlib>\n#include <sstream> // for std::stringstream\n\n// Define the Node structure\nstruct Node {\n    Node* l = nullptr;\n    Node* r = nullptr;\n    int check() const {\n        if (l)\n            return l->check() + 1 + r->check();\n        else\n            return 1;\n    }\n};\n\n// NodePool class for managing node allocations\nclass NodePool {\npublic:\n    NodePool(size_t pool_size) : pool_size_(pool_size) {\n        pool_ = new Node[pool_size_];\n        free_stack_.reserve(pool_size_);\n        for (size_t i = 0; i < pool_size_; ++i) {\n            free_stack_.push_back(&pool_[i]);\n        }\n    }\n\n    ~NodePool() {\n        delete[] pool_;  // delete allocated array\n    }\n\n    Node* allocate() {\n        if (free_stack_.empty()) {\n            throw std::bad_alloc();\n        }\n        Node* node = free_stack_.back();\n        free_stack_.pop_back();\n        node->l = node->r = nullptr;\n        return node;\n    }\n\n    void deallocate(Node* node) {\n        free_stack_.push_back(node);\n    }\n\nprivate:\n    size_t pool_size_;\n    Node* pool_;\n    std::vector<Node*> free_stack_;\n};\n\n// Create trees iteratively\nNode* make_iterative(int d, NodePool& pool) {\n    struct StackNode {\n        Node* node;\n        int depth;\n    };\n\n    std::stack<StackNode> stack;\n\n    Node* root = pool.allocate();\n    stack.push({root, d});\n\n    while (!stack.empty()) {\n        StackNode current = stack.top();\n        stack.pop();\n        if (current.depth > 0) {\n            current.node->l = pool.allocate();\n            current.node->r = pool.allocate();\n            stack.push({current.node->r, current.depth - 1});\n            stack.push({current.node->l, current.depth - 1});\n        }\n    }\n    return root;\n}\n\n// Free all nodes in a tree\nvoid free_tree(Node* root, NodePool& pool) {\n    if (!root) return;\n\n    std::stack<Node*> nodes;\n    nodes.push(root);\n\n    while (!nodes.empty()) {\n        Node* node = nodes.top();\n        nodes.pop();\n        if (node->l) nodes.push(node->l);\n        if (node->r) nodes.push(node->r);\n        pool.deallocate(node);\n    }\n}\n\n// Entry point\nint main(int argc, char* argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? std::atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    NodePool pool((1 << (stretch_depth + 1)) - 1);  // Node pool\n\n    // Create and free a stretch tree\n    Node* stretch_tree = make_iterative(stretch_depth, pool);\n    std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t\" << \"check: \" << stretch_tree->check() << std::endl;\n    free_tree(stretch_tree, pool);\n\n    // Long-lived tree\n    Node* long_lived_tree = make_iterative(max_depth, pool);\n\n    // Construct output\n    std::vector<std::string> outputs((max_depth / 2) - 1);\n\n    #pragma omp parallel\n    {\n        std::vector<std::string> local_outputs(outputs.size());\n\n        #pragma omp for\n        for (int d = min_depth; d <= max_depth; d += 2) {\n            int iterations = 1 << (max_depth - d + min_depth);\n            int c = 0;  // local check counter\n\n            for (int i = 1; i <= iterations; ++i) {\n                Node* a = make_iterative(d, pool);\n                c += a->check();\n                free_tree(a, pool);\n            }\n\n            std::stringstream ss;\n            ss << iterations << \"\\t trees of depth \" << d << \"\\t check: \" << c << \"\\n\";\n\n            local_outputs[(d - min_depth) / 2] = ss.str();\n        }\n\n        #pragma omp critical\n        {\n            for (size_t i = 0; i < local_outputs.size(); ++i) {\n                if (!local_outputs[i].empty()){\n                    outputs[i].append(local_outputs[i]);\n                }\n            }\n        }\n    }\n\n    for (const auto& result : outputs) {\n        std::cout << result;\n    }\n\n    // Long-lived tree check\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t\" << \"check: \" << long_lived_tree->check() << \"\\n\";\n\n    free_tree(long_lived_tree, pool);\n\n    return 0;\n}",
        15.633,
        341.647
    ]
}