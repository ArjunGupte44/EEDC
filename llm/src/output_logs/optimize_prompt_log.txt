You are tasked with optimizing the following C++ code for energy efficiency, specifically focusing on reducing CPU cycles, minimizing memory access, and optimizing I/O operations. Analyze the code thoroughly and suggest multiple optimization strategies, considering the following aspects:

                Reduction of nested loops: Identify opportunities to simplify or eliminate nested loops to reduce computational overhead.
                Efficient data structure selection: Propose data structures that minimize memory access and improve performance.
                Dynamic programming or memoization: Look for opportunities to avoid redundant calculations and reduce CPU cycles.
                Specialized algorithms: Explore if more efficient algorithms can be applied to lower resource usage.
                I/O optimization: Suggest ways to optimize input/output operations, reducing their impact on performance.
                Code simplicity and readability: Ensure that the optimized code remains understandable while achieving energy efficiency.
                
                Provide a detailed step-by-step explanation of your analysis and the reasoning behind each optimization strategy. After evaluating the pros and cons of each approach, choose the most effective strategy and implement the necessary changes directly into the code. Make sure the optimized code and the original code provide the same output in the same format for any given input. This is critical to the optimization.
                
                Here is an example of desirable optimization:
                Example of optimization: 
                Example of cpp code to be optimized:
                ```
                #include <iostream>
                #include <vector>

                using namespace std;

                // Inefficient code for finding duplicates in a vector of user IDs
                vector<int> findDuplicates(const vector<int>& userIds) {
                    vector<int> duplicates;
                    for (size_t i = 0; i < userIds.size(); ++i) {
                        for (size_t j = i + 1; j < userIds.size(); ++j) {
                            if (userIds[i] == userIds[j]) {
                                duplicates.push_back(userIds[i]);
                            }
                        }
                    }
                    return duplicates;
                }

                int main() {
                    vector<int> userIds = {1, 2, 3, 2, 4, 5, 1, 3, 5};
                    vector<int> duplicates = findDuplicates(userIds);

                    cout << "Duplicate user IDs: ";
                    for (int id : duplicates) {
                        cout << id << " ";
                    }
                    cout << endl;

                    return 0;
                }
                ```

                Here is the actual code to be optimized: 
                ```
                #include <iostream>
                #include <vector>
                #include <unordered_set>

                using namespace std;

                // Optimized code for finding duplicates in a vector of user IDs
                vector<int> findDuplicates(const vector<int>& userIds) {
                    unordered_set<int> seen;  // Set to track seen user IDs
                    unordered_set<int> duplicates;  // Set to store duplicates
                    for (int id : userIds) {
                        if (seen.find(id) != seen.end()) {
                            duplicates.insert(id);  // Add to duplicates if already seen
                        } else {
                            seen.insert(id);  // Mark as seen
                        }
                    }
                    return vector<int>(duplicates.begin(), duplicates.end());  // Convert set to vector
                }

                int main() {
                    vector<int> userIds = {1, 2, 3, 2, 4, 5, 1, 3, 5};
                    vector<int> duplicates = findDuplicates(userIds);

                    cout << "Duplicate user IDs: ";
                    for (int id : duplicates) {
                        cout << id << " ";
                    }
                    cout << endl;

                    return 0;
                }
                ```
 #include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <apr_pools.h>


const size_t    LINE_SIZE = 64;

class Apr
{
public:
    Apr() 
    {
        apr_initialize();
    }

    ~Apr() 
    {
        apr_terminate();
    }
};

struct Node 
{
    Node *l, *r;
    
    int check() const 
    {
        if (l)
            return l->check() + 1 + r->check();
        else return 1;
    }
};

class NodePool
{
public:
    NodePool() 
    {
        apr_pool_create_unmanaged(&pool);
    }

    ~NodePool() 
    {
        apr_pool_destroy(pool);
    }

    Node* alloc()
    {
        return (Node *)apr_palloc(pool, sizeof(Node));
    }

    void clear()
    {
        apr_pool_clear(pool);
    }

private:
    apr_pool_t* pool;
};

Node *make(int d, NodePool &store)
{
    Node* root = store.alloc();

    if(d>0){
        root->l=make(d-1, store);
        root->r=make(d-1, store);
    }else{
        root->l=root->r=0;
    }

    return root;
}

int main(int argc, char *argv[]) 
{
    Apr apr;
    int min_depth = 4;
    int max_depth = std::max(min_depth+2,
                             (argc == 2 ? atoi(argv[1]) : 10));
    int stretch_depth = max_depth+1;

    // Alloc then dealloc stretchdepth tree
    {
        NodePool store;
        Node *c = make(stretch_depth, store);
        std::cout << "stretch tree of depth " << stretch_depth << "\t "
                  << "check: " << c->check() << std::endl;
    }

    NodePool long_lived_store;
    Node *long_lived_tree = make(max_depth, long_lived_store);

    // buffer to store output of each thread
    char *outputstr = (char*)malloc(LINE_SIZE * (max_depth +1) * sizeof(char));

    #pragma omp parallel for 
    for (int d = min_depth; d <= max_depth; d += 2) 
    {
        int iterations = 1 << (max_depth - d + min_depth);
        int c = 0;

        // Create a memory pool for this thread to use.
        NodePool store;

        for (int i = 1; i <= iterations; ++i) 
        {
            Node *a = make(d, store);
            c += a->check();
            store.clear();
        }

        // each thread write to separate location
        sprintf(outputstr + LINE_SIZE * d, "%d\t trees of depth %d\t check: %d\n",
           iterations, d, c);
    }

    // print all results
    for (int d = min_depth; d <= max_depth; d += 2) 
        printf("%s", outputstr + (d * LINE_SIZE) );
    free(outputstr);

    std::cout << "long lived tree of depth " << max_depth << "\t "
              << "check: " << (long_lived_tree->check()) << "\n";

    return 0;
} 